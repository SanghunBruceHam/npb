<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="2025年シーズン最新のNPB順位表。セ・パ両リーグの勝率・ゲーム差・残り試合・優勝マジックナンバー・CS進出状況をリアルタイム更新。">
    <meta name="keywords" content="NPB, NPB 順位表, プロ野球, マジックナンバー, 勝率, ゲーム差, CS進出, リアルタイム">
    <meta name="author" content="NPB Statistics">
    <meta name="robots" content="index, follow">
    <meta name="language" content="ja">
    <link rel="canonical" href="https://npb-dashboard.com/">
    <link rel="sitemap" type="application/xml" href="https://npb-dashboard.com/sitemap.xml">
    <meta name="theme-color" content="#333">
    <meta name="application-name" content="NPB Dashboard">
    <meta name="msapplication-TileColor" content="#333">
    <meta name="google-site-verification" content="placeholder-verification-code">
    <meta name="google-adsense-account" content="ca-pub-5508768187151867">
    
    <title>NPB 順位表 2025｜プロ野球 勝率・ゲーム差・マジックナンバー・CS進出状況</title>
    
    <!-- Favicon -->
    <link rel="icon" type="image/png" sizes="32x32" href="favicon.png">
    <link rel="icon" type="image/png" sizes="16x16" href="favicon.png">
    <link rel="apple-touch-icon" href="favicon.png">
    <link rel="shortcut icon" href="favicon.png">
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://npb-dashboard.com/">
    <meta property="og:title" content="NPB順位表 2025｜勝率・ゲーム差・マジックナンバー・CS進出状況">
    <meta property="og:description" content="2025年シーズン最新のNPB順位表。セ・パ両リーグの勝率・ゲーム差・残り試合・優勝マジックナンバー・CS進出状況をリアルタイム更新。">
    <meta property="og:image" content="https://npb-dashboard.com/images/npb-og-image.jpg">
    <meta property="og:image:width" content="1200">
    <meta property="og:image:height" content="630">
    <meta property="og:site_name" content="NPB Statistics">
    <meta property="og:locale" content="ja_JP">
    <meta property="article:publisher" content="https://npb-dashboard.com">
    <meta property="article:section" content="Sports">
    
    <!-- Twitter -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:url" content="https://npb-dashboard.com/">
    <meta name="twitter:title" content="NPB 順位表 2025｜マジック・CS進出状況">
    <meta name="twitter:description" content="2025年シーズン最新のNPB順位表。セ・パ両リーグの勝率・ゲーム差・残り試合・優勝マジックナンバー・CS進出状況をリアルタイム更新。">
    <meta name="twitter:image" content="https://npb-dashboard.com/images/npb-og-image.jpg">
    <meta name="twitter:site" content="@npb_dashboard">
    <meta name="twitter:creator" content="@npb_dashboard">
    
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-LFKN46L0P6"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);} 
      gtag('js', new Date());
      gtag('config', 'G-LFKN46L0P6');
    </script>
    
    <!-- Google AdSense -->
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5508768187151867" crossorigin="anonymous"></script>
    
    <!-- Structured Data -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": ["WebApplication", "SportsOrganization"],
      "name": "NPB Statistics Dashboard",
      "description": "NPB(日本プロ野球)2025年シーズンの順位表とマジックナンバー情報をリアルタイムで追跡するダッシュボード",
      "url": "https://npb-dashboard.com/",
      "applicationCategory": "Sports Statistics",
      "operatingSystem": "Any",
      "browserRequirements": "Modern web browser",
      "sport": "Baseball",
      "foundingDate": "2025",
      "offers": {
        "@type": "Offer",
        "price": "0",
        "priceCurrency": "USD"
      },
      "featureList": [
        "リアルタイム順位表",
        "マジックナンバー計算",
        "プレーオフ進出状況",
        "勝率シナリオ分析",
        "残り試合数統計"
      ],
      "keywords": "日本プロ野球,NPB,順位表,マジック,優勝,プレーオフ,CS,野球統計",
      "inLanguage": "ja",
      "audience": {
        "@type": "Audience",
        "audienceType": "Baseball fans",
        "geographicArea": {
          "@type": "Country",
          "name": "Japan"
        }
      },
      "about": {
        "@type": "SportsEvent",
        "name": "NPB 2025 Regular Season",
        "startDate": "2025-03-29",
        "endDate": "2025-10-31",
        "sport": "Baseball",
        "location": {
          "@type": "Country",
          "name": "Japan"
        },
        "organizer": {
          "@type": "SportsOrganization",
          "name": "Nippon Professional Baseball",
          "url": "https://npb.jp"
        },
        "subEvent": [
          {
            "@type": "SportsEvent",
            "name": "セントラル・リーグ",
            "sport": "Baseball"
          },
          {
            "@type": "SportsEvent", 
            "name": "パシフィック・リーグ",
            "sport": "Baseball"
          }
        ]
      },
      "provider": {
        "@type": "Organization",
        "name": "NPB Statistics"
      },
      "dateModified": "2025-09-08",
      "isAccessibleForFree": true
    }
    </script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: Arial, sans-serif;
            background: white;
            color: black;
            font-size: 14px;
            line-height: 1.4;
            min-width: 320px;
            margin: 0;
            padding: 0;
        }
        
        .header {
            background: #333;
            color: white;
            padding: 10px 20px;
            position: sticky;
            top: 0;
            z-index: 1000;
        }
        
        .header-content {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .site-name {
            font-size: 16px;
            font-weight: bold;
            color: white;
            text-decoration: none;
        }
        
        .language-selector {
            display: flex;
            gap: 5px;
            align-items: center;
        }
        
        .lang-btn {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 3px;
            padding: 4px 8px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s ease;
        }
        
        .lang-btn:hover {
            background: rgba(255, 255, 255, 0.3);
        }
        
        .lang-btn.active {
            background: #fff;
            color: #333;
            font-weight: bold;
        }
        
        h1 { 
            font-size: 18px; 
            margin: 0; 
            font-weight: bold;
        }
        
        .nav {
            background: #f5f5f5;
            border-bottom: 2px solid #ddd;
            width: 100%;
            position: sticky;
            top: 46px; /* Adjust based on header height */
            z-index: 999;
        }
        
        .nav-tabs { 
            display: flex; 
            max-width: 1200px; 
            margin: 0 auto;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        .nav-tab { 
            padding: 10px 15px; 
            cursor: pointer; 
            border-right: 1px solid #ddd; 
            font-size: 13px; 
            background: #f5f5f5; 
            border: none; 
            font-family: inherit;
            flex: 1;
            min-width: 120px;
            text-align: center;
            white-space: nowrap;
        }
        
        .nav-tab:hover { 
            background: #e9e9e9; 
        }
        
        .nav-tab.active { 
            background: white; 
            font-weight: bold; 
            border-bottom: 2px solid #0066cc; 
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            padding-top: 10px;
            width: 100%;
        }
        
        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
            padding-top: 0px; /* Reset padding */
            margin-top: 20px; /* Add margin instead of padding */
        }
        
        h2 { 
            font-size: 16px; 
            margin: 15px 0 8px 0; 
            font-weight: bold; 
        }
        
        h3 {
            font-size: 14px;
            margin: 10px 0;
            font-weight: bold;
        }
        
        table { 
            border-collapse: collapse; 
            width: 100%; 
            margin: 10px 0;
            table-layout: fixed;
        }
        
        th, td { 
            border: 1px solid #ddd; 
            padding: 4px 6px; 
            text-align: left; 
            font-size: 13px; 
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            line-height: 1.2;
            height: 30px;
            vertical-align: middle;
        }
        
        /* 컬럼별 고정 폭 설정 */
        th:nth-child(1), td:nth-child(1) { width: 30px; }     /* 순위 */
        th:nth-child(2), td:nth-child(2) { width: 150px; }    /* 팀명 */
        th:nth-child(3), td:nth-child(3) { width: 35px; }     /* 試合/승 */
        th:nth-child(4), td:nth-child(4) { width: 28px; }     /* 勝/패 */
        th:nth-child(5), td:nth-child(5) { width: 28px; }     /* 敗/분 */
        th:nth-child(6), td:nth-child(6) { width: 28px; }     /* 分/승률 */
        th:nth-child(7), td:nth-child(7) { width: 50px; }     /* 勝率 */
        th:nth-child(8), td:nth-child(8) { width: 55px; }     /* ゲーム差 */
        th:nth-child(9), td:nth-child(9) { width: 55px; }     /* 残り試合 */
        th:nth-child(10), td:nth-child(10) { width: 45px; }   /* 最大勝 */
        th:nth-child(11), td:nth-child(11) { width: 55px; }   /* 1位条件 */
        th:nth-child(12), td:nth-child(12) { width: 50px; }   /* マジック */
        th:nth-child(13), td:nth-child(13) { width: 70px; }   /* エリミネート */
        th:nth-child(14), td:nth-child(14) { width: 55px; }   /* 進出状況 */
        th:nth-child(15), td:nth-child(15) { width: 55px; }   /* 추가 컬럼 */
        
        th { 
            background: #f5f5f5; 
            font-weight: bold;
            padding: 6px 4px;
        }
        
        tr:nth-child(even) { 
            background: #f9f9f9; 
        }
        
        .leagues { 
            display: grid; 
            /* Always stack leagues vertically (Central above Pacific) */
            grid-template-columns: 1fr; 
            gap: 30px; 
            margin: 20px 0; 
        }
        
        .center { 
            text-align: center; 
        }
        
        .right { 
            text-align: right; 
        }
        
        .rank1 { 
            background: #e8f1ff; 
        }
        
        .rank2 { 
            background: #f0f0f0; 
        }
        
        .rank3 { 
            background: #f3f8ff; 
        }
        
        .win { 
            color: #0066cc; 
        }
        
        .loss { 
            color: #cc0000; 
        }
        
        .pct { 
            font-weight: bold; 
        }
        
        .info { 
            font-size: 13px; 
            color: #333; 
            margin: 10px 0;
            text-align: center;
        }
        
        .loading { 
            text-align: center; 
            padding: 20px; 
            color: #444; 
        }
        
        .magic-number { 
            font-size: 15px; 
            font-weight: bold; 
            color: #0066cc; 
        }
        
        .eliminated { 
            color: #cc0000; 
        }
        
        .clinched { 
            color: #00aa00; 
        }

        .scroll-table { 
            overflow-x: auto; 
        }

        /* Today schedule */
        .today-section {
            background: #fffef8;
            border: 1px solid #eee0b3;
            border-radius: 6px;
            padding: 12px;
            margin: 16px 0 10px 0;
        }
        .today-section h2 {
            display: flex;
            align-items: baseline;
            gap: 8px;
        }
        .today-count { font-size: 12px; color: #666; font-weight: normal; }
        
        /* Progress Tab Styles */
        .league-progress {
            background: #fff;
            border-radius: 10px;
            padding: 20px;
            border: 1px solid #ddd;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }
        
        .team-progress-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            padding: 12px;
            border-radius: 8px;
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            transition: background-color 0.2s ease;
        }
        
        .team-progress-item:hover {
            background: #e9ecef;
        }
        
        .team-progress-name {
            width: 120px;
            font-weight: 600;
            font-size: 14px;
            color: #333;
            display: flex;
            align-items: center;
        }
        
        .team-progress-name img {
            margin-right: 6px;
        }
        
        .team-progress-bar {
            flex: 1;
            height: 18px;
            background: #e0e0e0;
            border-radius: 9px;
            margin: 0 12px;
            overflow: hidden;
            border: 1px solid #ccc;
        }
        
        .team-progress-fill {
            height: 100%;
            transition: width 0.8s ease;
            border-radius: 8px;
            background: linear-gradient(90deg, currentColor, currentColor);
        }
        
        .team-progress-text {
            width: 70px;
            text-align: right;
            font-size: 13px;
            font-weight: 700;
            color: #333;
        }
        
        .stat-card {
            background: #fff;
            border: 1px solid #ddd;
            border-radius: 10px;
            padding: 18px;
            text-align: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            transition: transform 0.2s ease;
        }
        
        .stat-card:hover {
            transform: translateY(-2px);
        }
        
        .stat-title {
            font-size: 13px;
            color: #666;
            margin-bottom: 8px;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .stat-value {
            font-size: 20px;
            font-weight: bold;
            color: #2e7d32;
            line-height: 1.2;
        }
        .today-date {
            font-size: 13px;
            color: #666;
            font-weight: normal;
        }
        .games-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-top: 10px;
        }
        .game-card {
            border: 1px solid #e6e6e6;
            border-radius: 4px;
            padding: 6px 8px;
            background: #fff;
            min-width: 0;
            margin-bottom: 4px;
        }
        .game-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 6px;
            font-weight: bold;
            line-height: 1.2;
        }
        .game-row span {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            flex-shrink: 1;
        }
        .game-row span:first-child,
        .game-row span:last-child {
            max-width: 45%;
        }
        .game-sub {
            margin-top: 2px;
            font-size: 11px;
            color: #666;
            line-height: 1.1;
        }
        .league-tag {
            display: inline-block;
            font-size: 12px;
            padding: 2px 6px;
            border-radius: 10px;
            border: 1px solid #bbb;
            background: #f7f7f7;
        }
        .league-central { background: #e8f2ff; border-color: #b7d3ff; }
        .league-pacific { background: #e9fff0; border-color: #b9efcd; }

        /* Toggle */
        .schedule-toggle { margin-top: 8px; }
        .toggle-group {
            display: inline-flex;
            border: 1px solid #ddd;
            border-radius: 999px;
            overflow: hidden;
            background: #fafafa;
        }
        .toggle-btn {
            padding: 6px 12px;
            font-size: 13px;
            border: none;
            background: transparent;
            cursor: pointer;
        }
        .toggle-btn.active {
            background: white;
            color: #000;
            font-weight: bold;
        }
        
        @media (max-width: 768px) {
            .leagues {
                grid-template-columns: 1fr;
                gap: 20px;
            }

            .container {
                padding: 10px;
            }

            .nav-tabs {
                flex-direction: column;
            }

            .nav {
                top: 39px; /* Adjust for mobile header height */
            }

            .nav-tab {
                width: 100%;
                border-right: none;
                border-bottom: 1px solid #ddd;
            }
            
            .games-grid {
                grid-template-columns: 1fr;
            }
            
            .game-row span:first-child,
            .game-row span:last-child {
                max-width: 40%;
                font-size: 12px;
            }
            
            table { 
                font-size: 12px; 
            }
            
            th, td { 
                padding: 4px 6px; 
            }
            
            .nav-tab { 
                padding: 8px 10px; 
                font-size: 12px; 
                white-space: nowrap;
            }
            
            .scroll-table {
                width: 100%;
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
            }

            .scroll-table table {
                min-width: 600px;
            }

            .games-grid { grid-template-columns: 1fr; }
        }

        /* Layout: sticky footer without JS (flex column) */
        html, body { height: 100%; }
        body { display: flex; flex-direction: column; min-height: 100vh; }
        main { flex: 1 0 auto; }
        
        /* Simple site footer (flow layout; pushed to bottom by flex) */
        .site-footer {
            margin-top: auto;
            background: #ffffff; border-top: 1px solid #cfcfcf;
            box-shadow: 0 -2px 8px rgba(0,0,0,0.06);
        }
        .site-footer .footer-content {
            max-width: 1200px; margin: 0 auto; padding: 12px 20px;
            color: #222; font-size: 13px; line-height: 1.5;
            display: flex; justify-content: space-between; align-items: center; gap: 8px; flex-wrap: wrap;
        }
        .site-footer a { color: #0066cc; text-decoration: none; }
        .site-footer a:hover { text-decoration: underline; }
        .site-footer { padding-bottom: env(safe-area-inset-bottom); }
        .today-date { color: #444; }

        /* Team logo before name */
        .team-logo {
            height: 1.2em;
            width: auto;
            vertical-align: text-bottom;
            margin-right: 0.35em;
        }

        /* Remaining games matrix styles */
        .matrix-container {
            overflow-x: auto;
            margin: 20px auto;
            background: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            display: inline-block;
            max-width: 100%;
        }

        .remaining-matrix {
            display: grid;
            gap: 0;
            background: white;
            font-size: 13px;
            min-width: fit-content;
            margin: 0 auto;
        }

        .matrix-cell {
            background: white;
            padding: 6px;
            text-align: center;
            border: 1px solid #e0e0e0;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .matrix-header-team {
            background: #f8f9fa;
            font-weight: bold;
            padding: 8px 10px;
            text-align: left;
            white-space: nowrap;
            justify-content: flex-start;
            position: sticky;
            left: 0;
            z-index: 1;
            border-right: 2px solid #ddd;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 180px;
        }

        .matrix-header-opponent {
            background: #f8f9fa;
            font-weight: bold;
            padding: 8px 6px;
            text-align: center;
            white-space: nowrap;
            border-bottom: 2px solid #ddd;
            overflow: hidden;
            text-overflow: ellipsis;
            font-size: 13px;
            min-width: 100px;
        }
        
        .matrix-header-opponent .team-logo {
            height: 0.9em;
            width: auto;
            margin-right: 2px;
        }

        .matrix-data-cell {
            font-weight: normal;
            font-size: 14px;
            min-width: 100px;
        }

        .matrix-data-cell.zero {
            color: #ccc;
            background: #fafafa;
        }

        .matrix-data-cell.has-games {
            background: #e3f2fd;
            color: #1565c0;
            font-weight: bold;
        }

        .matrix-total-cell {
            background: #fff3e0;
            font-weight: bold;
            color: #e65100;
            border: 1px solid #ffcc80;
        }

        .matrix-corner {
            background: #37474f;
            color: white;
            font-size: 13px;
            font-weight: bold;
        }

        /* Responsive adjustments for matrix */
        @media (max-width: 768px) {
            .remaining-matrix {
                font-size: 12px;
            }
            
            .matrix-cell {
                padding: 6px;
            }
            
            .matrix-header-team {
                padding: 8px 6px;
            }
            
            .matrix-header-opponent {
                min-height: 100px;
                padding: 6px;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="header-content">
            <div style="display: flex; align-items: center; gap: 20px;">
                <a href="#" class="site-name" onclick="location.reload(); return false;">NPB Dashboard</a>
                <h1 data-i18n="main-title">NPB 2025シーズン 順位表・マジックナンバー・CS進出確率</h1>
            </div>
            <div class="language-selector">
                <button class="lang-btn active" onclick="changeLanguage('ja')" data-lang="ja">🇯🇵 日本語</button>
                <button class="lang-btn" onclick="changeLanguage('ko')" data-lang="ko">🇰🇷 한국어</button>
                <button class="lang-btn" onclick="changeLanguage('en')" data-lang="en">🇺🇸 English</button>
            </div>
        </div>
    </div>
    
    <div class="nav">
        <div class="nav-tabs">
            <div class="nav-tab" onclick="showTab('magic-regular', this)" data-i18n="nav-magic-regular">正規シーズン優勝マジック</div>
            <div class="nav-tab" onclick="showTab('magic-playoff', this)" data-i18n="nav-magic-playoff">プレーオフマジック</div>
            <div class="nav-tab" onclick="showTab('progress', this)" data-i18n="nav-progress">進行状況</div>
            <div class="nav-tab" onclick="showTab('scenarios', this)" data-i18n="nav-scenarios">経路の数</div>
            <div class="nav-tab" onclick="showTab('standings', this)" data-i18n="nav-standings">チーム順位</div>
            <div class="nav-tab" onclick="showTab('remaining', this)" data-i18n="nav-remaining">残り試合数</div>
        </div>
    </div>

    <main role="main">
    <div class="container">
        <!-- Meta info bar -->
        <div class="info" id="meta-bar">
            <span>最終更新: <span id="last-update">—</span></span>
            <span style="margin: 0 6px; color: #aaa;">·</span>
            <span>総試合数: <span id="total-games">—試合</span></span>
        </div>

        <!-- Today Schedule (Top of the page) -->
        <section id="today-section" class="today-section">
            <h2>今日の試合 <span id="today-count" class="today-count"></span>
                <span id="today-date" class="today-date"></span></h2>
            <div class="schedule-toggle">
                <div class="toggle-group" role="tablist" aria-label="Schedule Toggle">
                    <button id="btn-today" class="toggle-btn active" role="tab" aria-selected="true" data-i18n="today">今日</button>
                    <button id="btn-tomorrow" class="toggle-btn" role="tab" aria-selected="false" data-i18n="tomorrow">明日</button>
                </div>
            </div>
            <div id="today-games-container" class="games-grid">
                <div class="game-card"><div class="game-row">読み込み中...</div></div>
            </div>
        </section>

        
        
        <!-- AdSense Ad - Fixed Position (Outside Tabs) -->
        <div style="margin: 20px 0; text-align: center;">
            <ins class="adsbygoogle"
                 style="display:block; margin: 20px auto;"
                 data-ad-client="ca-pub-5508768187151867"
                 data-ad-slot="4067267701"
                 data-ad-format="auto"
                 data-full-width-responsive="true"></ins>
            <script>
                 (adsbygoogle = window.adsbygoogle || []).push({});
            </script>
        </div>

        <!-- Regular Season Magic Numbers -->
        <div id="magic-regular" class="tab-content active">
            <h2 data-i18n="title-regular-magic">2025年正規シーズン優勝マジックナンバー【セリーグ・パリーグ】</h2>
            
            <div class="leagues">
                <div>
                    <h3 data-i18n="central-league">セントラルリーグ</h3>
                    <table>
                        <thead>
                            <tr>
                                <th class="center" data-i18n="rank">順位</th>
                                <th data-i18n="team">チーム</th>
                                <th class="center" data-i18n="games-played">試合</th>
                                <th class="center" data-i18n="wins">勝</th>
                                <th class="center" data-i18n="losses">敗</th>
                                <th class="center" data-i18n="draws">分</th>
                                <th class="center" data-i18n="win-rate">勝率</th>
                                <th class="center" data-i18n="games-behind">ゲーム差</th>
                                <th class="center" data-i18n="remaining-games">残り試合</th>
                                <th class="center" data-i18n="max-wins">最大勝</th>
                                <th class="center" data-i18n="first-place-condition">1位条件</th>
                                <th class="center" data-i18n="magic">マジック</th>
                                <th class="center" data-i18n="eliminate">エリミネート</th>
                                <th class="center" data-i18n="playoff-status">進出状況</th>
                            </tr>
                        </thead>
                        <tbody id="central-magic-regular">
                            <tr><td colspan="13" class="loading">読み込み中...</td></tr>
                        </tbody>
                    </table>
                </div>

                <!-- AdSense Ad Between Leagues - Regular Magic -->
                <div style="margin: 20px 0; text-align: center; overflow: hidden;">
                    <ins class="adsbygoogle"
                         style="display:inline-block;max-width:100%;width:728px;height:90px"
                         data-ad-client="ca-pub-5508768187151867"
                         data-ad-slot="4067267701"></ins>
                </div>

                <div>
                    <h3 data-i18n="pacific-league">パシフィックリーグ</h3>
                    <table>
                        <thead>
                            <tr>
                                <th class="center" data-i18n="rank">順位</th>
                                <th data-i18n="team">チーム</th>
                                <th class="center" data-i18n="games-played">試合</th>
                                <th class="center" data-i18n="wins">勝</th>
                                <th class="center" data-i18n="losses">敗</th>
                                <th class="center" data-i18n="draws">分</th>
                                <th class="center" data-i18n="win-rate">勝率</th>
                                <th class="center" data-i18n="games-behind">ゲーム差</th>
                                <th class="center" data-i18n="remaining-games">残り試合</th>
                                <th class="center" data-i18n="max-wins">最大勝</th>
                                <th class="center" data-i18n="first-place-condition">1位条件</th>
                                <th class="center" data-i18n="magic">マジック</th>
                                <th class="center" data-i18n="eliminate">エリミネート</th>
                                <th class="center" data-i18n="playoff-status">進出状況</th>
                            </tr>
                        </thead>
                        <tbody id="pacific-magic-regular">
                            <tr><td colspan="13" class="loading">読み込み中...</td></tr>
                        </tbody>
                    </table>
                </div>
            </div>
            
            <div class="tab-help tab-help-magic-regular" style="background: #f8f9fa; border: 1px solid #dee2e6; border-radius: 4px; padding: 12px; margin: 15px 0; font-size: 13px; color: #333;">
                <strong>📊 マジック / エリミネーションの定義</strong><br>
                <div style="margin-top: 8px; line-height: 1.5;">
                • <strong>総試合数</strong>: NPBは各チーム<strong>143試合</strong><br>
                • <strong>勝率</strong>: 勝 / (勝 + 敗)（分は勝率に含めない）<br>
                • <strong>優勝マジック</strong>: (2位の<strong>最大可能勝数</strong>) − (1位の現在勝数) + 1（0以下で✓）<br>
                • <strong>エリミネート(E)</strong>: 1位勝数 ＞ チーム最大可能勝数, または <code>(143+1) − 1位勝 − チーム敗 ≤ 0</code><br>
                • <strong>記号</strong>: <strong>✓</strong>＝確定, <strong>E</strong>＝不可能, <strong>-</strong>＝該当なし
                </div>
            </div>
        </div>

        <!-- Playoff Magic Numbers -->
        <div id="magic-playoff" class="tab-content">
            <h2 data-i18n="title-playoff-magic">クライマックスシリーズ(CS)進出マジックナンバー【2025年最新】</h2>
            <div class="leagues">
                <div>
                    <h3 data-i18n="central-league-top3">セントラルリーグ (上位3チーム)</h3>
                    <table>
                        <thead>
                            <tr>
                                <th class="center" data-i18n="rank">順位</th>
                                <th data-i18n="team">チーム</th>
                                <th class="center" data-i18n="wins">勝</th>
                                <th class="center" data-i18n="losses">敗</th>
                                <th class="center" data-i18n="draws">分</th>
                                <th class="center" data-i18n="win-rate">勝率</th>
                                <th class="center" data-i18n="games-played">試合</th>
                                <th class="center" data-i18n="games-behind">ゲーム差</th>
                                <th class="center" data-i18n="remaining-games">残り試合</th>
                                <th class="center" data-i18n="max-wins">最大勝</th>
                                <th class="center" data-i18n="magic">マジック</th>
                                <th class="center" data-i18n="eliminate">エリミネート</th>
                                <th class="center" data-i18n="playoff-status">進出状況</th>
                            </tr>
                        </thead>
                        <tbody id="central-magic-playoff">
                            <tr><td colspan="13" class="loading">読み込み中...</td></tr>
                        </tbody>
                    </table>
                </div>

                <!-- AdSense Ad Between Leagues - Playoff Magic -->
                <div style="margin: 20px 0; text-align: center; overflow: hidden;">
                    <ins class="adsbygoogle"
                         style="display:inline-block;max-width:100%;width:728px;height:90px"
                         data-ad-client="ca-pub-5508768187151867"
                         data-ad-slot="4067267701"></ins>
                </div>

                <div>
                    <h3 data-i18n="pacific-league-top3">パシフィックリーグ (上位3チーム)</h3>
                    <table>
                        <thead>
                            <tr>
                                <th class="center" data-i18n="rank">順位</th>
                                <th data-i18n="team">チーム</th>
                                <th class="center" data-i18n="wins">勝</th>
                                <th class="center" data-i18n="losses">敗</th>
                                <th class="center" data-i18n="draws">分</th>
                                <th class="center" data-i18n="win-rate">勝率</th>
                                <th class="center" data-i18n="games-played">試合</th>
                                <th class="center" data-i18n="games-behind">ゲーム差</th>
                                <th class="center" data-i18n="remaining-games">残り試合</th>
                                <th class="center" data-i18n="max-wins">最大勝</th>
                                <th class="center" data-i18n="magic">マジック</th>
                                <th class="center" data-i18n="eliminate">エリミネート</th>
                                <th class="center" data-i18n="playoff-status">進出状況</th>
                            </tr>
                        </thead>
                        <tbody id="pacific-magic-playoff">
                            <tr><td colspan="13" class="loading">読み込み中...</td></tr>
                        </tbody>
                    </table>
                </div>
            </div>
            <div class="tab-help tab-help-magic-playoff" style="background: #fff3cd; border: 1px solid #ffeaa7; border-radius: 4px; padding: 12px; margin: 15px 0; font-size: 13px; color: #533f03;">
                <strong>🏆 クライマックスシリーズ (CS) 進出について</strong><br>
                <div style="margin-top: 8px; line-height: 1.5;">
                • <strong>進出チーム</strong>: 各リーグ（セ・パ）<strong>上位3チーム</strong>がCS進出<br>
                • <strong>ファーストステージ</strong>: 2位vs3位（3戦2勝制）<br>
                • <strong>ファイナルステージ</strong>: 1位vsファーストステージ勝者（6戦4勝制、1位に1勝アドバンテージ）<br>
                • <strong>マジック</strong>: CS進出確定までの必要勝数（✓で確定）<br>
                • <strong>エリミネート(E)</strong>: CS進出の可能性が消失（数値は残り敗数の許容値）<br>
                • <strong>進出状況</strong>: ファイナル直行（1位） / ファーストステージ（2位・3位）
                </div>
            </div>
        </div>

        <!-- Scenarios -->
        <div id="scenarios" class="tab-content">
            <h2 data-i18n="title-scenarios">経路の数（場合の数）</h2>

            <!-- Central League Scenario Views -->
            <div style="margin-bottom: 20px;">
                <h3 data-i18n="central-league">セントラルリーグ</h3>
                <div class="schedule-toggle" style="margin: 8px 0;">
                    <div class="toggle-group" role="tablist" aria-label="Central Scenario View">
                        <button id="btn-central-matrix" class="toggle-btn active" role="tab" aria-selected="true" data-i18n="matrix">マトリクス</button>
                        <button id="btn-central-detailed" class="toggle-btn" role="tab" aria-selected="false" data-i18n="detailed">詳細</button>
                    </div>
                </div>
                <div id="central-scenario-matrix" class="scenario-section" style="display: none;">
                    <div id="central-scenario-content"></div>
                </div>
                <div id="central-scenario-detailed" class="scenario-section" style="display: none;"></div>
            </div>

            <!-- AdSense Ad Between Leagues - Scenarios -->
            <div style="margin: 20px 0; text-align: center;">
                <ins class="adsbygoogle"
                     style="display:block"
                     data-ad-client="ca-pub-5508768187151867"
                     data-ad-slot="4067267701"
                     data-ad-format="auto"
                     data-full-width-responsive="true"></ins>
            </div>

            <!-- Pacific League Scenario Views -->
            <div>
                <h3 data-i18n="pacific-league">パシフィックリーグ</h3>
                <div class="schedule-toggle" style="margin: 8px 0;">
                    <div class="toggle-group" role="tablist" aria-label="Pacific Scenario View">
                        <button id="btn-pacific-matrix" class="toggle-btn active" role="tab" aria-selected="true" data-i18n="matrix">マトリクス</button>
                        <button id="btn-pacific-detailed" class="toggle-btn" role="tab" aria-selected="false" data-i18n="detailed">詳細</button>
                    </div>
                </div>
                <div id="pacific-scenario-matrix" class="scenario-section" style="display: none;">
                    <div id="pacific-scenario-content"></div>
                </div>
                <div id="pacific-scenario-detailed" class="scenario-section" style="display: none;"></div>
            </div>

            <div class="tab-help tab-help-scenarios" style="background: #e7f3ff; border: 1px solid #b3d7ff; border-radius: 4px; padding: 12px; margin: 15px 0; font-size: 13px; color: #003566;">
                <strong>📈 勝率別シナリオ分析</strong><br>
                <div style="margin-top: 8px; line-height: 1.5;">
                • <strong>マトリクス</strong>: 残り勝敗ごとの最終勝率を横断比較<br>
                • <strong>詳細</strong>: 上位チームの全残り勝敗組み合わせを一覧<br>
                • <strong>赤い仕切り線</strong>: <u>3位ライン</u>（CS進出枠の境界）<br>
                • <strong>表示対象</strong>: <u>3位進出の可能性が残るチームのみ</u>を表示（3位進出脱落が確定したチームは自動的に非表示）
                </div>
            </div>
        </div>

        <!-- Detailed Standings -->
        <div id="standings" class="tab-content">
            <h2 data-i18n="title-detailed-standings">NPB詳細順位表【勝率・ゲーム差・残り試合数】</h2>
            <div class="scroll-table">
                <h3 data-i18n="central-league">セントラルリーグ</h3>
                <table>
                    <thead>
                        <tr>
                            <th class="center">順位</th>
                            <th>チーム</th>
                            <th class="center">試合</th>
                            <th class="center">勝</th>
                            <th class="center">敗</th>
                            <th class="center">分</th>
                            <th class="center">勝率</th>
                            <th class="center">残り</th>
                            <th class="center">差</th>
                            <th class="center">ホーム</th>
                            <th class="center">ホーム率</th>
                            <th class="center">アウェー</th>
                            <th class="center">アウェー率</th>
                            <th class="center">最高順位</th>
                            <th class="center">最低順位</th>
                        </tr>
                    </thead>
                    <tbody id="central-detailed">
                        <tr><td colspan="15" class="loading">読み込み中...</td></tr>
                    </tbody>
                </table>
            </div>

            <!-- AdSense Ad Between Leagues - Standings -->
            <div style="margin: 20px 0; text-align: center;">
                <ins class="adsbygoogle"
                     style="display:block"
                     data-ad-client="ca-pub-5508768187151867"
                     data-ad-slot="4067267701"
                     data-ad-format="auto"
                     data-full-width-responsive="true"></ins>
            </div>

            <div class="scroll-table" style="margin-top: 30px;">
                <h3 data-i18n="pacific-league">パシフィックリーグ</h3>
                <table>
                    <thead>
                        <tr>
                            <th class="center">順位</th>
                            <th>チーム</th>
                            <th class="center">試合</th>
                            <th class="center">勝</th>
                            <th class="center">敗</th>
                            <th class="center">分</th>
                            <th class="center">勝率</th>
                            <th class="center">残り</th>
                            <th class="center">差</th>
                            <th class="center">ホーム</th>
                            <th class="center">ホーム率</th>
                            <th class="center">アウェー</th>
                            <th class="center">アウェー率</th>
                            <th class="center">最高順位</th>
                            <th class="center">最低順位</th>
                        </tr>
                    </thead>
                    <tbody id="pacific-detailed">
                        <tr><td colspan="15" class="loading">読み込み中...</td></tr>
                    </tbody>
                </table>
            </div>
            <div class="tab-help tab-help-standings" style="background: #f1f3f5; border: 1px solid #dee2e6; border-radius: 4px; padding: 10px; margin: 10px 0; font-size: 12px; color: #333;">
                • <strong>勝率</strong>= 勝 / (勝+敗), <strong>残り</strong>= 143 − 試合, <strong>差</strong>= 首位からのゲーム差<br>
                • <strong>分</strong>は勝率に含まれません。表示は最新JSONに基づきます。
            </div>
        </div>

        <!-- Remaining Games -->
        <div id="remaining" class="tab-content">
            <h2 data-i18n="title-remaining-matrix">残り試合対戦マトリクス【チーム別対戦予定】</h2>
            <div style="margin: 20px 0;">
                <h3 data-i18n="central-league">セントラルリーグ</h3>
                <div class="matrix-container">
                    <div id="central-remaining-matrix" class="remaining-matrix">
                        <div class="loading">読み込み中...</div>
                    </div>
                </div>
            </div>

            <!-- AdSense Ad Between Leagues - Remaining Games -->
            <div style="margin: 20px 0; text-align: center;">
                <ins class="adsbygoogle"
                     style="display:block"
                     data-ad-client="ca-pub-5508768187151867"
                     data-ad-slot="4067267701"
                     data-ad-format="auto"
                     data-full-width-responsive="true"></ins>
            </div>

            <div style="margin: 20px 0;">
                <h3 data-i18n="pacific-league">パシフィックリーグ</h3>
                <div class="matrix-container">
                    <div id="pacific-remaining-matrix" class="remaining-matrix">
                        <div class="loading">読み込み中...</div>
                    </div>
                </div>
            </div>
            <div class="tab-help tab-help-remaining" style="background: #f1f3f5; border: 1px solid #dee2e6; border-radius: 4px; padding: 10px; margin: 10px 0; font-size: 12px; color: #333;">
                • <strong>縦軸(左側)</strong>: ホームチーム、<strong>横軸(上部)</strong>: アウェーチーム<br>
                • <strong>数字</strong>: 今後予定されている対戦数<br>
                • <strong>チーム名</strong>: ロゴ付き日本語名で表示<br>
                • <strong>合計</strong>: 各チームの残り試合数が右端・下部に表示
            </div>
        </div>

        <!-- Progress Tab -->
        <div id="progress" class="tab-content">
            <h2 data-i18n="title-progress">2025年シーズン進行状況【消化試合数・進捗率】</h2>
            
            <!-- 전체 소화율 섹션 -->
            <div style="margin: 20px 0;">
                <h3>🏆 シーズン全体進行率</h3>
                <div id="season-progress" style="background: #f8f9fa; padding: 20px; border-radius: 8px; margin: 15px 0;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                        <span style="font-size: 18px; font-weight: bold;">全体進行率</span>
                        <span id="overall-percentage" style="font-size: 24px; font-weight: bold; color: #2e7d32;">—%</span>
                    </div>
                    <div id="overall-progress-bar" style="width: 100%; height: 20px; background: #e0e0e0; border-radius: 10px; overflow: hidden;">
                        <div id="overall-progress-fill" style="height: 100%; background: linear-gradient(90deg, #4caf50, #2e7d32); width: 0%; transition: width 0.5s ease;"></div>
                    </div>
                    <div style="display: flex; justify-content: space-between; margin-top: 10px; font-size: 14px; color: #666;">
                        <span>完了: <span id="completed-games">—</span>試合</span>
                        <span>残り: <span id="remaining-total">—</span>試合</span>
                        <span>総試合数: <span id="total-season-games">—</span>試合</span>
                    </div>
                </div>
            </div>

            <!-- 팀별 진행률 섹션 -->
            <div style="margin: 20px 0;">
                <h3>📊 チーム別進行状況</h3>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 15px 0;">
                    
                    <!-- 센트럴리그 -->
                    <div>
                        <h4>セントラルリーグ</h4>
                        <div id="central-progress" class="league-progress">
                            <div class="loading">データ読み込み中...</div>
                        </div>
                    </div>

                    <!-- AdSense Ad Between Leagues - Progress -->
                    <div style="grid-column: 1/-1; margin: 20px 0; text-align: center;">
                        <ins class="adsbygoogle"
                             style="display:block"
                             data-ad-client="ca-pub-5508768187151867"
                             data-ad-slot="4067267701"
                             data-ad-format="horizontal"
                             data-full-width-responsive="true"></ins>
                    </div>

                    <!-- 퍼시픽리그 -->
                    <div>
                        <h4>パシフィックリーグ</h4>
                        <div id="pacific-progress" class="league-progress">
                            <div class="loading">データ読み込み中...</div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 추가 통계 섹션 -->
            <div style="margin: 20px 0;">
                <h3>📈 詳細統計</h3>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                    <div class="stat-card">
                        <div class="stat-title">平均消化率</div>
                        <div class="stat-value" id="average-progress">—%</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-title">最高進行チーム</div>
                        <div class="stat-value" id="highest-team">—</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-title">最低進行チーム</div>
                        <div class="stat-value" id="lowest-team">—</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-title">進行差</div>
                        <div class="stat-value" id="progress-gap">—試合</div>
                    </div>
                </div>
            </div>

            <div class="tab-help" style="background: #f1f3f5; border: 1px solid #dee2e6; border-radius: 4px; padding: 10px; margin: 10px 0; font-size: 12px; color: #333;">
                • <strong>進行率</strong>: 각チームが消化した試合数 / 143試合 × 100%<br>
                • <strong>全体進行率</strong>: 전チーム平均の進行状況<br>
                • <strong>残り試合</strong>: 143 - 현재の消化試合数<br>
                • 데이터は최新の順位表に基づいて자동更新されます
            </div>
        </div>
        </section>
    </main>

    <script>
        // ===== 다국어 번역 데이터 =====
        const translations = {
            ja: {
                // 메인 헤더
                'main-title': 'NPB 2025シーズン 順位表・マジックナンバー・CS進出確率',
                
                // 네비게이션 탭
                'nav-magic-regular': '優勝マジック',
                'nav-magic-playoff': 'プレーオフマジック', 
                'nav-scenarios': '経路の数',
                'nav-standings': 'チーム順位',
                'nav-remaining': '残り試合数',
                'nav-progress': '進行状況',
                
                // 섹션 제목
                'title-regular-magic': '2025年正規シーズン優勝マジックナンバー【セリーグ・パリーグ】',
                'title-playoff-magic': 'クライマックスシリーズ(CS)進出マジックナンバー【2025年最新】',
                'title-detailed-standings': 'NPB詳細順位表【勝率・ゲーム差・残り試合数】',
                'title-remaining-matrix': '残り試合対戦マトリクス【チーム別対戦予定】',
                'title-progress': '2025年シーズン進行状況【消化試合数・進捗率】',
                'title-scenarios': '経路の数（場合の数）',
                
                // 리그명
                'central-league': 'セントラルリーグ',
                'pacific-league': 'パシフィックリーグ',
                'central-league-top3': 'セントラルリーグ (上位3チーム)',
                'pacific-league-top3': 'パシフィックリーグ (上位3チーム)',
                
                // 테이블 헤더
                'rank': '順位',
                'team': 'チーム',
                'games-played': '試合',
                'wins': '勝',
                'losses': '敗',
                'draws': '分',
                'win-rate': '勝率',
                'games-behind': 'ゲーム差',
                'remaining-games': '残り試合',
                'max-wins': '最大勝',
                'first-place-condition': '1位条件',
                'magic': 'マジック',
                'eliminate': 'エリミネート',
                'playoff-status': '進出状況',
                'clinch': 'クリンチ',
                'runs-scored': '得点',
                'runs-allowed': '失点',
                'run-differential': '得失点差',
                
                // 버튼
                'today': '今日',
                'tomorrow': '明日',
                'matrix': 'マトリクス',
                'detailed': '詳細',
                
                // 도움말 및 설명
                'help-regular-magic': '<strong>🏆 正規シーズン優勝マジックナンバー</strong><br>各チームが優勝を確定するために必要な最少勝利数です。他チームの結果に関係なく、この数だけ勝てば優勝が決定します。「✓」は既に優勝確定済みを示します。',
                'help-playoff-magic': '<strong>🏆 クライマックスシリーズ (CS) 進出について</strong><br>セリーグ・パリーグともに上位3チームがCS進出。3位以内確定に必要な最少勝利数を表示。順位確定済みは「✓」で表示。',
                'help-scenarios': '<strong>📊 シナリオ分析について</strong><br>各チームが特定順位になる可能性のある場合の数を表示します。計算は残り試合の全パターンを考慮します。',
                'help-standings': '<strong>📋 順位表について</strong><br>現在の各チーム成績と順位です。勝率は引き分けを除外して計算されます。',
                'help-remaining': '<strong>🗓 残り試合について</strong><br>各チーム間の残り対戦数を表示します。数字は残り対戦回数を示します。',
                'help-progress': '<strong>📈 進行状況について</strong><br>シーズン全体および各チームの消化試合数と進捗率を表示します。',
                
                // 상태 메시지
                'championship-decided': '優勝決定',
                'playoff-secured': 'CS確定',
                'eliminated': '圏外確定',
                'still-possible': '可能性あり',
                
                // NPB 팀명 (일본어)
                'giants': '読売ジャイアンツ',
                'tigers': '阪神タイガース', 
                'dragons': '中日ドラゴンズ',
                'carp': '広島東洋カープ',
                'swallows': '東京ヤクルトスワローズ',
                'baystars': '横浜DeNAベイスターズ',
                'hawks': 'ソフトバンクホークス',
                'eagles': '東北楽天ゴールデンイーグルス',
                'lions': '埼玉西武ライオンズ',
                'marines': '千葉ロッテマリーンズ',
                'fighters': '北海道日本ハムファイターズ',
                'buffaloes': 'オリックスバファローズ',
                
                // 팀명 줄임말
                'giants-short': 'ジャイアンツ',
                'tigers-short': 'タイガース',
                'dragons-short': 'ドラゴンズ',
                'carp-short': 'カープ',
                'swallows-short': 'スワローズ',
                'baystars-short': 'ベイスターズ',
                'hawks-short': 'ホークス',
                'eagles-short': 'イーグルス',
                'lions-short': 'ライオンズ',
                'marines-short': 'マリーンズ',
                'fighters-short': 'ファイターズ',
                'buffaloes-short': 'バファローズ',
                
                // 조건 메시지
                'wins-needed': '勝必要',
                'championship-secured': '優勝確定済み',
                'playoff-advancement-secured': 'CS進出確定',
                'eliminated-short': 'E',
                'no-remaining-games': '残り試合なし',
                
                // 진행 상황 텍스트
                'games-completed': '完了',
                'games-remaining': '残り',
                'games-unit': '試合',
                'progress-gap': '試合差'
            },
            ko: {
                // 메인 헤더
                'main-title': 'NPB 2025시즌 순위표·매직넘버·CS진출확률',
                
                // 네비게이션 탭
                'nav-magic-regular': '정규시즌 우승 매직',
                'nav-magic-playoff': '플레이오프 매직',
                'nav-scenarios': '경로의 수',
                'nav-standings': '팀 순위',
                'nav-remaining': '남은 경기수',
                'nav-progress': '진행 상황',
                
                // 섹션 제목
                'title-regular-magic': '2025년 정규시즌 우승 매직넘버【센트럴·퍼시픽 리그】',
                'title-playoff-magic': '클라이맥스 시리즈(CS) 진출 매직넘버【2025년 최신】',
                'title-detailed-standings': 'NPB 상세 순위표【승률·게임차·남은경기수】',
                'title-remaining-matrix': '남은 경기 대전 매트릭스【팀별 대전 예정】',
                'title-progress': '2025년 시즌 진행 상황【소화경기수·진행률】',
                'title-scenarios': '경로의 수（경우의 수）',
                
                // 리그명
                'central-league': '센트럴리그',
                'pacific-league': '퍼시픽리그',
                'central-league-top3': '센트럴리그 (상위 3팀)',
                'pacific-league-top3': '퍼시픽리그 (상위 3팀)',
                
                // 테이블 헤더
                'rank': '순위',
                'team': '팀',
                'games-played': '경기',
                'wins': '승',
                'losses': '패',
                'draws': '무',
                'win-rate': '승률',
                'games-behind': '게임차',
                'remaining-games': '남은경기',
                'max-wins': '최대승수',
                'first-place-condition': '1위조건',
                'magic': '매직',
                'eliminate': '엘리미네이트',
                'playoff-status': '진출상황',
                'clinch': '클린치',
                'runs-scored': '득점',
                'runs-allowed': '실점',
                'run-differential': '득실점차',
                
                // 버튼
                'today': '오늘',
                'tomorrow': '내일',
                'matrix': '매트릭스',
                'detailed': '상세',
                'table': '필요승수표',
                
                // 도움말 및 설명
                'help-regular-magic': '<strong>🏆 정규시즌 우승 매직넘버</strong><br>각 팀이 우승을 확정하기 위해 필요한 최소 승리수입니다. 다른 팀의 결과에 관계없이 이 수만큼 승리하면 우승이 결정됩니다. 「✓」는 이미 우승이 확정됨을 나타냅니다.',
                'help-playoff-magic': '<strong>🏆 클라이맥스 시리즈 (CS) 진출에 대해</strong><br>센트럴·퍼시픽리그 모두 상위 3팀이 CS 진출. 3위 이내 확정에 필요한 최소 승리수를 표시. 순위 확정시 「✓」로 표시.',
                'help-scenarios': '<strong>📊 시나리오 분석에 대해</strong><br>각 팀이 특정 순위가 될 가능성이 있는 경우의 수를 표시합니다. 계산은 남은 경기의 모든 패턴을 고려합니다.',
                'help-standings': '<strong>📋 순위표에 대해</strong><br>현재 각 팀의 성적과 순위입니다. 승률은 무승부를 제외하고 계산됩니다.',
                'help-remaining': '<strong>🗓 남은 경기에 대해</strong><br>각 팀 간의 남은 대전수를 표시합니다. 숫자는 남은 대전 횟수를 나타냅니다.',
                'help-progress': '<strong>📈 진행 상황에 대해</strong><br>시즌 전체 및 각 팀의 소화 경기수와 진행률을 표시합니다.',
                
                // 상태 메시지
                'championship-decided': '우승 결정',
                'playoff-secured': 'CS 확정',
                'eliminated': '권외 확정',
                'still-possible': '가능성 있음',
                
                // NPB 팀명 (한국어)
                'giants': '요미우리 자이언츠',
                'tigers': '한신 타이거스',
                'dragons': '주니치 드래곤스',
                'carp': '히로시마 도요 카프',
                'swallows': '도쿄 야쿠르트 스왈로즈',
                'baystars': '요코하마 DeNA 베이스타스',
                'hawks': '소프트뱅크 호크스',
                'eagles': '토호쿠 라쿠텐 골든이글스',
                'lions': '사이타마 세이부 라이온스',
                'marines': '치바 롯데 마린스',
                'fighters': '홋카이도 닛폰햄 파이터스',
                'buffaloes': '오릭스 버팔로스',
                
                // 팀명 줄임말
                'giants-short': '자이언츠',
                'tigers-short': '타이거스',
                'dragons-short': '드래곤스',
                'carp-short': '카프',
                'swallows-short': '스왈로즈',
                'baystars-short': '베이스타스',
                'hawks-short': '호크스',
                'eagles-short': '이글스',
                'lions-short': '라이온스',
                'marines-short': '마린스',
                'fighters-short': '파이터스',
                'buffaloes-short': '버팔로스',
                
                // 조건 메시지
                'wins-needed': '승 필요',
                'championship-secured': '우승 확정',
                'playoff-advancement-secured': 'CS 진출 확정',
                'eliminated-short': 'E',
                'no-remaining-games': '남은 경기 없음',
                
                // 진행 상황 텍스트
                'games-completed': '완료',
                'games-remaining': '남은',
                'games-unit': '경기',
                'progress-gap': '경기차'
            },
            en: {
                // 메인 헤더
                'main-title': 'NPB 2025 Season Standings · Magic Numbers · CS Playoff Probability',
                
                // 네비게이션 탭
                'nav-magic-regular': 'Regular Season Magic',
                'nav-magic-playoff': 'Playoff Magic',
                'nav-scenarios': 'Path Count',
                'nav-standings': 'Team Standings',
                'nav-remaining': 'Remaining Games',
                'nav-progress': 'Season Progress',
                
                // 섹션 제목
                'title-regular-magic': '2025 Regular Season Championship Magic Numbers【Central・Pacific League】',
                'title-playoff-magic': 'Climax Series (CS) Advancement Magic Numbers【2025 Latest】',
                'title-detailed-standings': 'NPB Detailed Standings【Win Rate・Games Behind・Remaining Games】',
                'title-remaining-matrix': 'Remaining Games Matrix【Team vs Team Schedule】',
                'title-progress': '2025 Season Progress【Games Played・Progress Rate】',
                'title-scenarios': 'Path Count (Number of Cases)',
                
                // 리그명
                'central-league': 'Central League',
                'pacific-league': 'Pacific League',
                'central-league-top3': 'Central League (Top 3 Teams)',
                'pacific-league-top3': 'Pacific League (Top 3 Teams)',
                
                // 테이블 헤더
                'rank': 'Rank',
                'team': 'Team',
                'games-played': 'GP',
                'wins': 'W',
                'losses': 'L',
                'draws': 'T',
                'win-rate': 'PCT',
                'games-behind': 'GB',
                'remaining-games': 'Remaining',
                'max-wins': 'Max Wins',
                'first-place-condition': '1st Place Condition',
                'magic': 'Magic',
                'eliminate': 'Eliminate',
                'playoff-status': 'Playoff Status',
                'clinch': 'Clinch',
                'runs-scored': 'RS',
                'runs-allowed': 'RA',
                'run-differential': 'Diff',
                
                // 버튼
                'today': 'Today',
                'tomorrow': 'Tomorrow',
                'matrix': 'Matrix',
                'detailed': 'Detailed',
                'table': 'Win Requirements',
                
                // 도움말 및 설명
                'help-regular-magic': '<strong>🏆 Regular Season Championship Magic Numbers</strong><br>The minimum number of wins each team needs to secure the championship. Regardless of other teams\' results, winning this many games guarantees the championship. \"✓\" indicates championship already secured.',
                'help-playoff-magic': '<strong>🏆 About Climax Series (CS) Advancement</strong><br>Top 3 teams from both Central and Pacific leagues advance to CS. Shows minimum wins needed to secure top 3 position. \"✓\" indicates position already secured.',
                'help-scenarios': '<strong>📊 About Scenario Analysis</strong><br>Shows the number of possible cases where each team can finish at specific rankings. Calculations consider all possible patterns of remaining games.',
                'help-standings': '<strong>📋 About Standings</strong><br>Current performance and rankings of each team. Win percentage is calculated excluding ties.',
                'help-remaining': '<strong>🗓 About Remaining Games</strong><br>Shows remaining matchups between each team. Numbers indicate remaining games to be played.',
                'help-progress': '<strong>📈 About Season Progress</strong><br>Shows games played and progress rate for the entire season and each team.',
                
                // 상태 메시지
                'championship-decided': 'Championship Decided',
                'playoff-secured': 'CS Secured',
                'eliminated': 'Eliminated',
                'still-possible': 'Still Possible',
                
                // NPB 팀명 (영어)
                'giants': 'Yomiuri Giants',
                'tigers': 'Hanshin Tigers',
                'dragons': 'Chunichi Dragons',
                'carp': 'Hiroshima Toyo Carp',
                'swallows': 'Tokyo Yakult Swallows',
                'baystars': 'Yokohama DeNA BayStars',
                'hawks': 'SoftBank Hawks',
                'eagles': 'Tohoku Rakuten Golden Eagles',
                'lions': 'Saitama Seibu Lions',
                'marines': 'Chiba Lotte Marines',
                'fighters': 'Hokkaido Nippon-Ham Fighters',
                'buffaloes': 'Orix Buffaloes',
                
                // 팀명 줄임말
                'giants-short': 'Giants',
                'tigers-short': 'Tigers',
                'dragons-short': 'Dragons',
                'carp-short': 'Carp',
                'swallows-short': 'Swallows',
                'baystars-short': 'BayStars',
                'hawks-short': 'Hawks',
                'eagles-short': 'Eagles',
                'lions-short': 'Lions',
                'marines-short': 'Marines',
                'fighters-short': 'Fighters',
                'buffaloes-short': 'Buffaloes',
                
                // 조건 메시지
                'wins-needed': 'Wins Needed',
                'championship-secured': 'Championship Secured',
                'playoff-advancement-secured': 'CS Secured',
                'eliminated-short': 'E',
                'no-remaining-games': 'No Games Left',
                
                // 진행 상황 텍스트
                'games-completed': 'Completed',
                'games-remaining': 'Remaining',
                'games-unit': 'Games',
                'progress-gap': 'Games Gap'
            }
        };

        // ===== グローバル変数 =====
        let standingsData = null;      // 順位表データ
        let seasonConfig = null;       // シーズン設定データ  
        let gamesData = null;          // 全試合（完了分）データ
        let upcomingGamesData = null;  // 残り試合データ
        let homeAwayRemainingByTeam = {}; // { team_id: { home: n, away: n, opponents: {} } }
        let TOTAL_GAMES = 143;         // NPB 正規シーズン: 1チーム143試合

        // 기존 데이터 형식을 새 계산 함수용으로 변환하는 헬퍼
        function convertTeamDataForMagic(teams) {
            return teams.map(team => ({
                id: team.team_id || team.team_name,
                W: team.wins,
                L: team.losses,
                T: team.draws || 0
            }));
        }

        // ===== NPB 매직/트래직 넘버 계산 공통 유틸 함수들 =====
        function calcR(team, season=143) {
            return season - (team.W + team.L + team.T);
        }
        function winPct(team, R) { // 현재 승률
            const denom = team.W + team.L;
            return denom > 0 ? team.W / denom : 0;
        }
        function pMax(team, R) { // 남은 전승
            const denom = team.W + team.L + R;
            return denom > 0 ? (team.W + R) / denom : 0;
        }
        function pMin(team, R) { // 남은 전패
            const denom = team.W + team.L + R;
            return denom > 0 ? (team.W) / denom : 0;
        }
        function clamp(v, lo, hi) { return Math.max(lo, Math.min(hi, v)); }
        function round3(x){ return Number(x.toFixed(3)); }

        // ===== NPB 정규시즌 매직/트래직 계산 라이브러리 =====
        // 현재 순위표(승률 기준 내림차순). 무승부는 분모 제외
        function sortStandings(teams, season=143) {
            return [...teams].map(t => {
                const R = calcR(t, season);
                return { ...t, R, winPct: winPct(t, R) };
            }).sort((a,b)=> b.winPct - a.winPct);
        }

        // 모드 1) 공식 방식: 현재 1위 vs 현재 2위
        function officialLeaderMagicTragic(teams, season=143) {
            const table = sortStandings(teams, season);
            const leader = table[0];
            const runner = table[1];

            const R1 = leader.R;
            const D1 = leader.W + leader.L + R1;          // 최종 분모(무승부 제외)
            const R2 = runner.R;
            const D2 = runner.W + runner.L + R2;

            // 1위 확정(매직): (W1 + x) / D1  >  (W2 + R2) / D2  (strict) / ≥ (tieOK)
            const K1_official = (runner.W + R2) / D2;      // 2위의 최대 가능 승률
            const needWins_rhs = K1_official * D1 - leader.W;
            const x_strict = Math.max(0, Math.floor(needWins_rhs) + 1);
            const x_tieOK  = Math.max(0, Math.ceil(needWins_rhs));
            const x_strict_c = clamp(x_strict, 0, R1);
            const x_tieOK_c  = clamp(x_tieOK,  0, R1);

            // 1위 탈락(트래직): (W1 + R1 - y) / D1  ≤  (W2) / D2  (strict) / < (tieOK)
            const K1min_official = (runner.W) / D2;        // 2위의 최소 가능 승률
            const lose_rhs = leader.W + R1 - K1min_official * D1;
            const y_strict = Math.max(0, Math.ceil(lose_rhs));
            const y_tieOK  = Math.max(0, Math.floor(lose_rhs) + 1);
            const y_strict_c = clamp(y_strict, 0, R1);
            const y_tieOK_c  = clamp(y_tieOK,  0, R1);

            return {
                leader: { id: leader.id, W: leader.W, L: leader.L, T: leader.T, R: leader.R, winPct: round3(leader.winPct) },
                runnerUp: { id: runner.id, W: runner.W, L: runner.L, T: runner.T, R: runner.R, winPct: round3(runner.winPct) },
                K1_official: round3(K1_official),
                K1min_official: round3(K1min_official),
                x_strict: x_strict_c,   // 동률 불허
                x_tieOK:  x_tieOK_c,    // 동률 허용
                y_strict: y_strict_c,   // 동률 불허
                y_tieOK:  y_tieOK_c     // 동률 허용
            };
        }

        // 모드 2) 보수 방식: 전 팀 기준(최댓/최솟 승률)
        function conservativeAllTeamsMagicTragic(teams, season=143) {
            return teams.map(t => {
                const Ri = calcR(t, season);
                const Di = t.W + t.L + Ri;

                // 다른 팀들의 최대 가능 승률의 최댓값 (내가 넘어야 할 기준)
                let K1_max = 0;
                // 다른 팀들의 최소 가능 승률의 최댓값 (내가 못 미치면 탈락 보장)
                let K1_min = 0;

                for (const u of teams) {
                    if (u.id === t.id) continue;
                    const Ru = calcR(u, season);
                    K1_max = Math.max(K1_max, pMax(u, Ru));
                    K1_min = Math.max(K1_min, pMin(u, Ru));
                }

                // 매직넘버(1위 확정): (Wi + x)/Di > K1_max (strict) / ≥ (tieOK)
                const needWins_rhs = K1_max * Di - t.W;
                const x_strict = Math.max(0, Math.floor(needWins_rhs) + 1);
                const x_tieOK  = Math.max(0, Math.ceil(needWins_rhs));

                // 트래직넘버(1위 탈락): (Wi + Ri - y)/Di ≤ K1_min (strict) / < (tieOK)
                const lose_rhs = t.W + Ri - K1_min * Di;
                const y_strict = Math.max(0, Math.ceil(lose_rhs));
                const y_tieOK  = Math.max(0, Math.floor(lose_rhs) + 1);

                return {
                    team: t.id,
                    W: t.W, L: t.L, T: t.T, R: Ri,
                    winPct: round3(winPct(t, Ri)),
                    K1_max: round3(K1_max),
                    K1_min: round3(K1_min),
                    x_strict: clamp(x_strict, 0, Ri),
                    x_tieOK:  clamp(x_tieOK,  0, Ri),
                    y_strict: clamp(y_strict, 0, Ri),
                    y_tieOK:  clamp(y_tieOK,  0, Ri)
                };
            });
        }

        // 통합 엔트리 함수
        function npbRank1MagicTragic(teams, season=143) {
            const official = officialLeaderMagicTragic(teams, season);     // 현재 1위 전용(2위만 비교)
            const conservative = conservativeAllTeamsMagicTragic(teams, season); // 전 팀 보수 계산
            const leaderInfo = sortStandings(teams, season)[0];
            return {
                leader: { id: leaderInfo.id, W: leaderInfo.W, L: leaderInfo.L, T: leaderInfo.T, R: leaderInfo.R, winPct: round3(leaderInfo.winPct) },
                official: { onlyLeader: official },
                conservative: { rows: conservative }
            };
        }

        // ===== NPB 프레이오프(상위 3위) 매직/트래직 계산 라이브러리 =====
        function pNow(team) { // 현재 승률 (무승부 제외)
            const denom = team.W + team.L;
            return denom > 0 ? team.W / denom : 0;
        }

        function kthLargest(arr, k) {
            if (!arr.length || k < 1) return 0;
            const sorted = [...arr].sort((a, b) => b - a);
            return sorted[k - 1] ?? 0;
        }

        function kBenchmarksForTeam(i, teams, season, k) {
            const maxList = [];
            const minList = [];
            for (const t of teams) {
                if (t.id === i.id) continue;
                const R = calcR(t, season);
                maxList.push(pMax(t, R));
                minList.push(pMin(t, R));
            }
            return {
                Kk_max: kthLargest(maxList, k),
                Kk_min: kthLargest(minList, k)
            };
        }

        function magicTragicForK(team, season, k, Kk_max, Kk_min) {
            const Ri = calcR(team, season);
            const Di = team.W + team.L + Ri;

            // Magic (확정)
            const rhsMagic = Kk_max * Di - team.W;
            const x_strict = Math.max(0, Math.floor(rhsMagic) + 1); // >
            const x_tieOK  = Math.max(0, Math.ceil(rhsMagic));      // ≥

            // Tragic (탈락)
            const rhsTr = team.W + Ri - Kk_min * Di;
            const y_strict = Math.max(0, Math.ceil(rhsTr));         // ≤
            const y_tieOK  = Math.max(0, Math.floor(rhsTr) + 1);    // <

            return {
                R: Ri,
                x_strict: clamp(x_strict, 0, Ri),
                x_tieOK:  clamp(x_tieOK,  0, Ri),
                y_strict: clamp(y_strict, 0, Ri),
                y_tieOK:  clamp(y_tieOK,  0, Ri)
            };
        }

        function npbPlayoffMagicTragic(teams, season = 143, ks = [1, 2, 3]) {
            return teams.map(team => {
                const Ri = calcR(team, season);
                const row = {
                    team: team.id,
                    W: team.W, L: team.L, T: team.T, R: Ri,
                    winPct: round3(pNow(team))
                };

                for (const k of ks) {
                    const { Kk_max, Kk_min } = kBenchmarksForTeam(team, teams, season, k);
                    const res = magicTragicForK(team, season, k, Kk_max, Kk_min);
                    row[`K${k}_max`] = round3(Kk_max);
                    row[`K${k}_min`] = round3(Kk_min);
                    row[`x${k}_strict`] = res.x_strict;
                    row[`x${k}_tieOK`]  = res.x_tieOK;
                    row[`y${k}_strict`] = res.y_strict;
                    row[`y${k}_tieOK`]  = res.y_tieOK;
                }
                return row;
            });
        }

        // ===== チームロゴ（略称→ファイルパス） =====
        const TEAM_LOGOS = {
            YOG: 'assets/npb-logos/svg/yomiuri-giants.svg',
            HAN: 'assets/npb-logos/svg/hanshin-tigers.svg',
            CHU: 'assets/npb-logos/svg/chunichi-dragons.svg',
            HIR: 'assets/npb-logos/svg/hiroshima-toyo-carp.svg',
            YDB: 'assets/npb-logos/svg/yokohama-dena-baystars.svg',
            YAK: 'assets/npb-logos/svg/tokyo-yakult-swallows.svg',
            SOF: 'assets/npb-logos/svg/fukuoka-softbank-hawks.svg',
            LOT: 'assets/npb-logos/svg/chiba-lotte-marines.svg',
            SEI: 'assets/npb-logos/svg/saitama-seibu-lions.svg',
            ORI: 'assets/npb-logos/svg/orix-buffaloes.svg',
            NIP: 'assets/npb-logos/svg/hokkaido-nippon-ham-fighters.svg',
            RAK: 'assets/npb-logos/svg/tohoku-rakuten-golden-eagles.svg'
        };

        function renderTeamLabel(abbr, name, shortName = false) {
            const src = TEAM_LOGOS[abbr] || '';
            let safeName = name || abbr || '';
            
            // 팀명 번역 적용
            safeName = translateTeamName(safeName, shortName);
            
            const img = src ? `<img class="team-logo" src="${src}" alt="${safeName}" loading="lazy">` : '';
            return `${img}${safeName}`;
        }

        // ===== タブ切り替え機能 =====
        function showTab(tabId, el) {
            // Hide all tabs
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.remove('active');
                tab.setAttribute('aria-hidden', 'true');
            });

            // Reset all nav buttons
            document.querySelectorAll('.nav-tab').forEach(tab => {
                tab.classList.remove('active');
                tab.setAttribute('aria-selected', 'false');
            });

            // Show selected tab
            const selectedTab = document.getElementById(tabId);
            selectedTab.classList.add('active');
            selectedTab.setAttribute('aria-hidden', 'false');

            // Activate nav button
            if (el) {
                el.classList.add('active');
                el.setAttribute('aria-selected', 'true');
            } else {
                // If no element provided, find and activate the correct nav button
                document.querySelectorAll('.nav-tab').forEach(tab => {
                    if (tab.getAttribute('onclick') && tab.getAttribute('onclick').includes(`'${tabId}'`)) {
                        tab.classList.add('active');
                        tab.setAttribute('aria-selected', 'true');
                    }
                });
            }

            // Update URL hash
            window.location.hash = tabId;

            // Refresh AdSense ads when tab changes - only for visible ads
            setTimeout(() => {
                try {
                    // Only initialize ads in the currently active tab
                    const activeTab = document.querySelector('.tab-content.active');
                    if (activeTab) {
                        const ads = activeTab.querySelectorAll('.adsbygoogle');
                        ads.forEach(ad => {
                            if (!ad.dataset.adsbygoogleStatus && ad.offsetWidth > 0) {
                                (adsbygoogle = window.adsbygoogle || []).push({});
                            }
                        });
                    }
                } catch(e) {
                    console.log('AdSense refresh error:', e);
                }
            }, 200);


            // Static footer: no dynamic updates needed
        }


        // ===== 正規シーズン優勝マジック更新 =====
        function updateMagicRegular() {
            updateMagicTable('central-magic-regular', standingsData.central_league?.standings || [], true);
            updateMagicTable('pacific-magic-regular', standingsData.pacific_league?.standings || [], true);
        }

        // ===== プレーオフマジック更新 =====
        function updateMagicPlayoff() {
            updateMagicTable('central-magic-playoff', standingsData.central_league?.standings || [], false);
            updateMagicTable('pacific-magic-playoff', standingsData.pacific_league?.standings || [], false);
        }

        // ===== マジックナンバーテーブル更新（共通関数） =====
        function updateMagicTable(id, teams, isRegular) {
            const tbody = document.getElementById(id);
            if (!teams.length) {
                tbody.innerHTML = '<tr><td colspan="13" class="loading">データがありません</td></tr>';
                return;
            }

            // 매직넘버 계산을 위한 데이터 준비
            let magicResults = null;
            let useConservativeMode = false;
            let allowTies = true;
            
            if (isRegular) {
                // 정규시즌: 새로운 매직/트래직 계산 로직 사용
                const convertedTeams = convertTeamDataForMagic(teams);
                magicResults = npbRank1MagicTragic(convertedTeams, TOTAL_GAMES);
                
                // UI 표시 모드 설정 (라디오 버튼에서 읽어옴)
                useConservativeMode = document.querySelector('input[name="magic-mode"]:checked')?.value === 'conservative' || false;
                allowTies = document.querySelector('input[name="tie-mode"]:checked')?.value === 'allow' || true;
            }

            const leader = teams[0];
            const thirdPlace = teams[2] || {};
            
            tbody.innerHTML = teams.map(team => {
                const rankClass = team.position_rank === 1 ? 'rank1' : 
                                 team.position_rank === 2 ? 'rank2' : 
                                 team.position_rank === 3 ? 'rank3' : '';
                
                const remainingGames = TOTAL_GAMES - team.games_played;
                const maxWins = team.wins + remainingGames;
                let magic = '-';
                let clinch = '-';
                let csConfirmed = '-';  // 플레이오프용 CS확정 변수
                let eliminate = '-';
                let condition = '-';
                
                if (isRegular) {
                    // 正規シーズン優勝マジックナンバー計算
                    if (team.position_rank === 1) {
                        const secondPlace = teams[1];
                        if (secondPlace && remainingGames > 0) {
                            // マジックナンバー = （2位チームの最大可能勝数） - （1位チームの現在勝数） + 1
                            const secondPlaceRemaining = TOTAL_GAMES - secondPlace.games_played;
                            const secondPlaceMaxWins = secondPlace.wins + secondPlaceRemaining;
                            const magicNumber = secondPlaceMaxWins - team.wins + 1;
                            
                            if (magicNumber <= 0) {
                                magic = '✓'; // 優勝確定済
                                clinch = '優勝';
                                condition = '確定';
                            } else {
                                magic = magicNumber;
                                condition = `${magicNumber}勝必要`;
                            }
                        } else if (remainingGames === 0) {
                            magic = '✓'; // シーズン終了
                            clinch = '確定';
                            condition = '確定';
                        }
                    } else {
                        // 2位以下チームの優勝条件: 1位チームが何勝以下で終わる必要があるか
                        const teamMaxWins = team.wins + remainingGames;
                        const leaderCurrentWins = leader.wins;
                        const leaderRemaining = TOTAL_GAMES - leader.games_played;
                        
                        if (teamMaxWins <= leaderCurrentWins) {
                            condition = '不可能';
                        } else {
                            // このチームが1位になるために1位チームが最大何勝までに抑える必要があるか
                            const leaderMaxAllowed = teamMaxWins - 1;
                            if (leaderMaxAllowed < leaderCurrentWins) {
                                condition = '不可能';
                            } else {
                                condition = `1位${leaderMaxAllowed}勝以下`;
                            }
                        }
                    }
                    
                    // 새로운 트래직넘버 계산 (제공받은 로직 사용)
                    if (team.position_rank === 1) {
                        // 1위팀은 우승 탈락이 없으므로 엘리미네이션 표시 안함
                        eliminate = '-';
                    } else {
                        // 2위 이하 팀들의 우승 탈락 계산
                        if (useConservativeMode) {
                            const teamResult = magicResults.conservative.rows.find(r => r.team === (team.team_id || team.team_name));
                            if (teamResult) {
                                const tragicValue = allowTies ? teamResult.y_tieOK : teamResult.y_strict;
                                eliminate = tragicValue === 0 ? 'E' : (tragicValue >= teamResult.R ? 'E' : tragicValue);
                            }
                        } else {
                            // 기존 MLB 스타일 계산 유지 (하위 호환성)
                            const teamMaxWins = team.wins + remainingGames;
                            const alreadyEliminated = leader.wins > teamMaxWins;
                            if (alreadyEliminated) {
                                eliminate = 'E';
                            } else {
                                const combo = (TOTAL_GAMES + 1) - leader.wins - team.losses;
                                eliminate = combo <= 0 ? 'E' : combo;
                            }
                        }
                    }
                } else {
                    // 새로운 프레이오프 매직/트래직 계산 로직 사용
                    const convertedTeams = convertTeamDataForMagic(teams);
                    const playoffResults = npbPlayoffMagicTragic(convertedTeams, TOTAL_GAMES, [1, 2, 3]);
                    
                    // 현재 팀의 결과 찾기
                    const teamResult = playoffResults.find(r => r.team === (team.team_id || team.team_name));
                    
                    if (teamResult) {
                        // 단순하게 계산 결과만 표기
                        const x3_magic = teamResult.x3_tieOK; // 3위 확정 매직넘버
                        const x2_magic = teamResult.x2_tieOK; // 2위 확정 매직넘버  
                        const x1_magic = teamResult.x1_tieOK; // 1위 확정 매직넘버
                        
                        // 매직넘버 표시
                        if (x3_magic === 0) {
                            clinch = '✓';
                        } else {
                            clinch = x3_magic;
                        }
                        
                        // クライマックスシリーズ進出状態表示
                        if (x1_magic === 0) {
                            csConfirmed = 'ファイナル直行';
                            condition = 'ファイナル直行';
                        } else if (x2_magic === 0) {
                            csConfirmed = 'ファーストステージ';
                            condition = 'ファーストステージ';
                        } else if (x3_magic === 0) {
                            csConfirmed = 'ファーストステージ';
                            condition = 'ファーストステージ';
                        } else {
                            condition = `CS進出まで${x3_magic}勝`;
                        }
                    }
                    
                    // (기존 CS 확정 판정 로직 제거됨 - 새로운 로직이 이미 처리)
                    
                    // 엘리미네이션 계산 (단순하게)
                    if (teamResult) {
                        const y3_tragic = teamResult.y3_tieOK; // 3위 탈락 트래직넘버
                        if (y3_tragic === 0) {
                            eliminate = 'E';
                        } else {
                            eliminate = y3_tragic;
                        }
                    }
                }
                
                if (isRegular) {
                    // 정규시즌: 順位 チーム 勝 敗 分 勝率 ゲーム差 残り試合 最大勝 1位条件 マジック エリミネート 進出状況
                    return `
                        <tr class="${rankClass}">
                            <td class="center">${team.position_rank}</td>
                            <td>${renderTeamLabel(team.team_abbreviation, team.team_name)}</td>
                            <td class="center">${team.games_played}</td>
                            <td class="center win">${team.wins}</td>
                            <td class="center loss">${team.losses}</td>
                            <td class="center">${team.draws || 0}</td>
                            <td class="center pct">0.${team.win_percentage.toFixed(3).split('.')[1]}</td>
                            <td class="center">${team.games_behind > 0 ? team.games_behind.toFixed(1) : '-'}</td>
                            <td class="center">${remainingGames}</td>
                            <td class="center">${maxWins}</td>
                            <td class="center" style="font-size: 12px;">${translateCondition(condition)}</td>
                            <td class="center ${magic === '✓' ? 'clinched' : 'magic-number'}">${magic}</td>
                            <td class="center ${eliminate === 'E' ? 'eliminated' : ''}">${eliminate}</td>
                            <td class="center ${clinch !== '-' ? 'clinched' : ''}" style="font-size: 12px;">${clinch}</td>
                        </tr>
                    `;
                } else {
                    // 플레이오프: 順位 チーム 勝 敗 分 勝率 ゲーム差 残り試合 最大勝 3位条件 マジック エリミネート 進出状況
                    return `
                        <tr class="${rankClass}">
                            <td class="center">${team.position_rank}</td>
                            <td>${renderTeamLabel(team.team_abbreviation, team.team_name)}</td>
                            <td class="center">${team.games_played}</td>
                            <td class="center win">${team.wins}</td>
                            <td class="center loss">${team.losses}</td>
                            <td class="center">${team.draws || 0}</td>
                            <td class="center pct">0.${team.win_percentage.toFixed(3).split('.')[1]}</td>
                            <td class="center">${team.games_behind > 0 ? team.games_behind.toFixed(1) : '-'}</td>
                            <td class="center">${remainingGames}</td>
                            <td class="center">${maxWins}</td>
                            <td class="center ${clinch === '✓' ? 'clinched' : 'magic-number'}">${clinch}</td>
                            <td class="center ${eliminate === 'E' ? 'eliminated' : ''}">${eliminate}</td>
                            <td class="center ${csConfirmed !== '-' ? 'clinched' : ''}" style="font-size: 12px;">${csConfirmed}</td>
                        </tr>
                    `;
                }
            }).join('');
        }

        // ===== 詳細順位表更新 =====
        function updateDetailedStandings() {
            updateDetailedTable('central-detailed', standingsData.central_league?.standings || []);
            updateDetailedTable('pacific-detailed', standingsData.pacific_league?.standings || []);
        }

        // ===== 詳細順位テーブル更新（共通関数） =====
        function updateDetailedTable(id, teams) {
            const tbody = document.getElementById(id);
            if (!teams.length) {
                tbody.innerHTML = '<tr><td colspan="15" class="loading">データがありません</td></tr>';
                return;
            }

            tbody.innerHTML = teams.map(team => {
                const rankClass = team.position_rank === 1 ? 'rank1' : 
                                 team.position_rank === 2 ? 'rank2' : 
                                 team.position_rank === 3 ? 'rank3' : '';
                
                const remainingGames = TOTAL_GAMES - team.games_played;
                
                // ホーム/アウェイ分割シミュレート（実データなしの場合の仮計算）
                const homeAdvantage = seasonConfig?.display_config?.home_advantage || 0.55;
                const homeGames = Math.floor(team.games_played / 2);
                const awayGames = team.games_played - homeGames;
                const homeWins = Math.floor(team.wins * homeAdvantage); // ホームアドバンテージ計算
                const awayWins = team.wins - homeWins;
                const homeLosses = homeGames - homeWins;
                const awayLosses = awayGames - awayWins;
                const homeWinPct = homeGames > 0 ? '0.' + (homeWins / homeGames).toFixed(3).split('.')[1] : '0.000';
                const awayWinPct = awayGames > 0 ? '0.' + (awayWins / awayGames).toFixed(3).split('.')[1] : '0.000';
                
                // 最高/最低順位可能性計算
                const maxWins = team.wins + remainingGames;  // このチームの最大可能勝数
                const minWins = team.wins;                   // このチームの最小可能勝数（現在勝数）
                
                // 最高順位計算: 他チームが最悪成績で終わった場合
                let bestRank = 1;
                teams.forEach(other => {
                    if (other.team_id !== team.team_id) {
                        const otherMinWins = other.wins; // 他チームの最小勝数（現在勝数）
                        if (otherMinWins > maxWins) {
                            bestRank++; // このチームより上位確定
                        }
                    }
                });
                
                // 最低順位計算: 他チームが最高成績で終わった場合  
                let worstRank = 1;
                teams.forEach(other => {
                    if (other.team_id !== team.team_id) {
                        const otherMaxWins = other.wins + (TOTAL_GAMES - other.games_played);
                        if (otherMaxWins > minWins) {
                            worstRank++; // このチームより上位可能
                        }
                    }
                });
                
                // CS進出/脱落状況を用いた現実的な範囲補正（簡易）
                // 4位の最大可能勝数（全チームの最大可能勝数の4番目）
                const allMaxWins = teams
                    .map(t => t.wins + (TOTAL_GAMES - t.games_played))
                    .sort((a, b) => b - a);
                const fourthHighestMaxWins = allMaxWins[3] ?? 0;
                const thirdPlace = teams[2];
                
                // CS確定なら最低順位は3位以内
                if (team.wins > fourthHighestMaxWins) {
                    worstRank = Math.min(worstRank, 3);
                }
                // 3位の現在勝数に最大でも届かないなら最高順位は4位以下
                if (thirdPlace && (team.wins + remainingGames) < thirdPlace.wins) {
                    bestRank = Math.max(bestRank, 4);
                }

                // 順位は1-6位に制限
                bestRank = Math.min(bestRank, 6);
                worstRank = Math.min(worstRank, 6);
                
                return `
                    <tr class="${rankClass}">
                        <td class="center">${team.position_rank}</td>
                        <td>${renderTeamLabel(team.team_abbreviation, team.team_name)}</td>
                        <td class="center">${team.games_played}</td>
                        <td class="center win">${team.wins}</td>
                        <td class="center loss">${team.losses}</td>
                        <td class="center">${team.draws || 0}</td>
                        <td class="center pct">0.${team.win_percentage.toFixed(3).split('.')[1]}</td>
                        <td class="center">${remainingGames}</td>
                        <td class="center">${team.games_behind > 0 ? team.games_behind.toFixed(1) : '-'}</td>
                        <td class="center">${homeWins}-${homeLosses}</td>
                        <td class="center">${homeWinPct}</td>
                        <td class="center">${awayWins}-${awayLosses}</td>
                        <td class="center">${awayWinPct}</td>
                        <td class="center">${bestRank}</td>
                        <td class="center">${worstRank}</td>
                    </tr>
                `;
            }).join('');
        }

        // ===== 勝率シナリオ分析更新 =====
        function updateScenarios() {
            // Table references have been removed, only update matrix and detailed views
            renderScenarioMatrixFor('central');
            renderScenarioMatrixFor('pacific');
        }

        // ===== 勝率シナリオテーブル更新（共通関数） =====
        function updateScenariosTable(id, teams) {
            // This function is no longer needed since we removed the table view
            return;

            // Filter: show only teams still able to reach 3位 (CS)
            let displayTeams = teams;
            if (teams.length >= 3) {
                const thirdWins = teams[2]?.wins || 0;
                displayTeams = teams.filter(t => (t.wins + (TOTAL_GAMES - t.games_played)) >= thirdWins);
            }

            // Create NPB-style 4-row header
            if (header) {
                let headerHTML = `
                    <tr>
                        <td rowspan="4" style="background: #f8f9fa; font-weight: bold; vertical-align: middle; width: 60px;">최종승률</td>`;
                
                // Row 1: Team rankings
                displayTeams.forEach(team => {
                    headerHTML += `<td class="center" style="background: #f0f0f0; font-weight: bold; padding: 4px;">${team.position_rank}위</td>`;
                });
                headerHTML += `</tr><tr>`;
                
                // Row 2: Team names with logos
                displayTeams.forEach(team => {
                    headerHTML += `<td class="center" style="background: #f8f9fa; font-weight: bold; padding: 4px;">${renderTeamLabel(team.team_abbreviation, team.team_name)}</td>`;
                });
                headerHTML += `</tr><tr>`;
                
                // Row 3: Current records + games played
                displayTeams.forEach(team => {
                    headerHTML += `<td class="center" style="background: #f0f0f0; font-size: 12px; padding: 4px;">${team.wins}-${team.losses}-${team.draws || 0} (試合${team.games_played})</td>`;
                });
                headerHTML += `</tr><tr>`;
                
                // Row 4: Remaining games
                displayTeams.forEach(team => {
                    const remaining = TOTAL_GAMES - team.games_played;
                    headerHTML += `<td class="center" style="background: #f8f9fa; font-size: 12px; padding: 4px;">잔여${remaining}</td>`;
                });
                headerHTML += `</tr>`;
                
                header.innerHTML = headerHTML;
            }

            // 表示する勝率ターゲット（高い順から） - 動的設定
            const winRateTargets = seasonConfig?.scenario_config?.win_rate_targets || [0.700, 0.650, 0.600, 0.550, 0.500, 0.450, 0.400, 0.350, 0.300];
            
            tbody.innerHTML = winRateTargets.map(targetRate => {
                let row = `<td class="center" style="background: #f8f9fa; font-weight: bold; padding: 4px; font-size: 12px;">${(targetRate * 100).toFixed(0)}%</td>`;
                
                displayTeams.forEach(team => {
                    const remainingGames = TOTAL_GAMES - team.games_played;
                    const currentWins = team.wins;
                    const currentLosses = team.losses;
                    const currentDraws = team.draws || 0;
                    
                    // 目標勝率達成に必要な残り成績計算
                    const totalGamesMinusDraws = TOTAL_GAMES - currentDraws;
                    const requiredTotalWins = Math.ceil(targetRate * totalGamesMinusDraws);
                    const requiredWins = Math.max(0, requiredTotalWins - currentWins);
                    const requiredLosses = remainingGames - requiredWins;
                    
                    let cellContent = '';
                    let cellStyle = 'text-align: center; padding: 4px; font-size: 10px; min-width: 40px;';
                    
                    if (requiredWins > remainingGames) {
                        // 達成不可能
                        cellContent = '-';
                        cellStyle += 'background: #ffebee; color: #c62828;';
                    } else if (requiredWins <= 0) {
                        // 既に達成または容易
                        const finalRate = (currentWins / (TOTAL_GAMES - currentDraws)) * 100;
                        if (finalRate >= targetRate * 100) {
                            cellContent = '✓';
                            cellStyle += 'background: #e3f2fd; color: #0d47a1; font-weight: bold;';
                        } else {
                            cellContent = `${requiredWins}-${requiredLosses}`;
                            cellStyle += 'background: #e3f2fd; color: #0d47a1;';
                        }
                    } else {
                        // 必要成績表示: 勝-敗
                        cellContent = `${requiredWins}-${requiredLosses}`;
                        
                        // 最終勝率を0.500と比較して色分け
                        const finalRate = (currentWins + requiredWins) / (TOTAL_GAMES - currentDraws);
                        if (finalRate > 0.500) {
                            cellStyle += 'background: #e3f2fd; color: #0d47a1;'; // Blue - above .500
                        } else if (finalRate === 0.500) {
                            cellStyle += 'background: #eceff1; color: #37474f;'; // Blue-gray - exactly .500
                        } else {
                            cellStyle += 'background: #ffebee; color: #c62828;'; // Red - below .500
                        }
                    }
                    
                    row += `<td style="${cellStyle}">${cellContent}</td>`;
                });
                
                return `<tr>${row}</tr>`;
            }).join('');
        }

        // ====== シナリオ・マトリクス（場合の数）機能 ======
        const NPB_TEAM_META = {
            YOG: { shortName: '巨人',  fullName: '読売ジャイアンツ',     color: '#333' },
            HAN: { shortName: '阪神',  fullName: '阪神タイガース',       color: '#333' },
            CHU: { shortName: '中日',  fullName: '中日ドラゴンズ',       color: '#333' },
            HIR: { shortName: '広島',  fullName: '広島東洋カープ',       color: '#333' },
            YDB: { shortName: 'DeNA', fullName: '横浜DeNAベイスターズ', color: '#333' },
            YAK: { shortName: 'ヤク',  fullName: '東京ヤクルトスワローズ', color: '#333' },
            SOF: { shortName: 'SB',   fullName: '福岡ソフトバンクホークス', color: '#333' },
            LOT: { shortName: 'ロッテ',fullName: '千葉ロッテマリーンズ',   color: '#333' },
            SEI: { shortName: '西武', fullName: '埼玉西武ライオンズ',     color: '#333' },
            ORI: { shortName: 'オリ', fullName: 'オリックスバファローズ', color: '#333' },
            NIP: { shortName: '日ハム', fullName: '北海道日本ハムファイターズ', color: '#333' },
            RAK: { shortName: '楽天', fullName: '東北楽天ゴールデンイーグルス', color: '#333' },
        };

        function getLeagueScenarioTeams(league) {
            const teams = league === 'central'
                ? (standingsData?.central_league?.standings || [])
                : (standingsData?.pacific_league?.standings || []);
            return teams.map(t => ({
                team: t.team_abbreviation,
                teamName: t.team_name,
                rank: t.position_rank,
                displayRank: t.position_rank,
                wins: t.wins,
                losses: t.losses,
                draws: t.draws || 0,
                winRate: t.win_percentage,
                remainingGames: Math.max(0, TOTAL_GAMES - (t.games_played || (t.wins + t.losses + (t.draws || 0))))
            })).sort((a,b) => a.rank - b.rank);
        }

        function setScenarioView(league, view) {
            const prefix = league === 'central' ? 'central' : 'pacific';
            const btnMatrix = document.getElementById(`btn-${prefix}-matrix`);
            const btnDetailed = document.getElementById(`btn-${prefix}-detailed`);
            const elMatrix = document.getElementById(`${prefix}-scenario-matrix`);
            const elDetailed = document.getElementById(`${prefix}-scenario-detailed`);

            // Toggle buttons
            btnMatrix?.classList.toggle('active', view === 'matrix');
            btnMatrix?.setAttribute('aria-selected', String(view === 'matrix'));
            btnDetailed?.classList.toggle('active', view === 'detailed');
            btnDetailed?.setAttribute('aria-selected', String(view === 'detailed'));

            // Toggle sections
            if (elMatrix) elMatrix.style.display = (view === 'matrix') ? 'block' : 'none';
            if (elDetailed) elDetailed.style.display = (view === 'detailed') ? 'block' : 'none';

            // Render when needed
            if (view === 'matrix') {
                renderScenarioMatrixFor(league);
            } else if (view === 'detailed') {
                renderDetailedScenariosFor(league);
            }
        }

        function renderScenarioMatrixFor(league) {
            const teams = getLeagueScenarioTeams(league);
            // Show only teams still in contention for 3rd place (CS)
            let contenders = teams;
            if (teams.length >= 3) {
                const thirdWins = teams[2]?.wins || 0;
                contenders = teams.filter(t => (t.wins + t.remainingGames) >= thirdWins);
            }
            const top = contenders.slice(0, Math.min(6, contenders.length));
            const html = generateScenarioMatrixV2(top);
            const targetId = league === 'central' ? 'central-scenario-content' : 'pacific-scenario-content';
            const container = document.getElementById(targetId);
            if (container) container.innerHTML = html;
        }

        function renderDetailedScenariosFor(league) {
            const teams = getLeagueScenarioTeams(league);
            // Show only teams still in contention for 3rd place (CS)
            let contenders = teams;
            if (teams.length >= 3) {
                const thirdWins = teams[2]?.wins || 0;
                contenders = teams.filter(t => (t.wins + t.remainingGames) >= thirdWins);
            }
            const top = contenders.slice(0, Math.min(6, contenders.length));
            const html = generateDetailedScenarios(top);
            const targetId = league === 'central' ? 'central-scenario-detailed' : 'pacific-scenario-detailed';
            const container = document.getElementById(targetId);
            if (container) container.innerHTML = html;
        }

        function bindScenarioViewToggles() {
            // Central
            document.getElementById('btn-central-matrix')?.addEventListener('click', () => setScenarioView('central','matrix'));
            document.getElementById('btn-central-detailed')?.addEventListener('click', () => setScenarioView('central','detailed'));
            // Pacific
            document.getElementById('btn-pacific-matrix')?.addEventListener('click', () => setScenarioView('pacific','matrix'));
            document.getElementById('btn-pacific-detailed')?.addEventListener('click', () => setScenarioView('pacific','detailed'));
        }

        function generateScenarioMatrix(topTeams) {
            let html = `
                <div class="scenario-matrix-container" style="
                    overflow-x: auto; overflow-y: auto; border-radius: 12px; border: 1px solid #e0e0e0; box-shadow: 0 2px 8px rgba(0,0,0,0.1);
                    max-height: 80vh; width: 100%; position: relative;">
                    <table class="scenario-matrix-table" style="width: 100%; border-collapse: collapse; font-size: 0.75rem; background: white; min-width: ${window.innerWidth <= 768 ? '700px' : Math.max(900, 6 * (70 + 85) + 70 + 140) + 'px'};">
                        <thead style="position: sticky; top: 0; z-index: 100;">
                          <tr style="background: #1E88E5; color: white;">
                            <th style="position: sticky; left: 0; z-index: 110; min-width: 70px; width: 70px; padding: 4px 6px; text-align: center; font-weight: 600; border-right: 2px solid rgba(255,255,255,0.4); background: #1E88E5; font-size: 0.7rem;">勝率</th>`;

            // Header team columns
            topTeams.forEach((team, index) => {
                const isLast = index === topTeams.length - 1;
                const teamMeta = NPB_TEAM_META[team.team];
                const teamColor = teamMeta?.color || '#333';
                const totalColumnWidth = '140px';
                const logo = TEAM_LOGOS[team.team] ? `<img class=\"team-logo\" src=\"${TEAM_LOGOS[team.team]}\" alt=\"${teamMeta?.fullName || team.team}\" loading=\"lazy\">` : '';
                html += `<th colspan="2" style="min-width: ${totalColumnWidth}; width: ${totalColumnWidth}; padding: 6px 4px 3px 4px; text-align: center; font-weight: 700; background: #F0F2F5; color: ${teamColor}; ${index === 2 ? 'border-right: 4px solid #FF6B35;' : (!isLast ? 'border-right: 2px solid rgba(255,255,255,0.5);' : '')} font-size: 0.8rem; white-space: nowrap; line-height: 1.2;"> 
                    <div style="font-size: 0.85rem; font-weight: 800; color: ${teamColor};">${team.displayRank || team.rank}位 ${logo}${teamMeta?.shortName || team.team}</div>
                </th>`;
            });

            // Current record row
            html += `</tr><tr style="background: #1E88E5; color: white;">
                <th style="position: sticky; left: 0; z-index: 110; min-width: 70px; width: 70px; padding: 4px 6px; text-align: center; font-weight: 600; border-right: 2px solid rgba(255,255,255,0.4); background: #1E88E5; font-size: 0.7rem;">成績</th>`;
            topTeams.forEach((team, index) => {
                const isLast = index === topTeams.length - 1;
                html += `<th colspan="2" style="min-width: 140px; width: 140px; padding: 4px; text-align: center; font-weight: 600; background: rgba(255,255,255,0.9); color: #333; ${index === 2 ? 'border-right: 4px solid #FF6B35;' : (!isLast ? 'border-right: 2px solid rgba(255,255,255,0.5);' : '')} font-size: 0.7rem;">${team.wins}勝 ${team.losses}敗 ${team.draws || 0}分 (0.${(team.winRate ?? (team.wins/(team.wins+team.losses))).toFixed(3).split('.')[1]})</th>`;
            });

            // Remaining row
            html += `</tr><tr style="background: #1E88E5; color: white;">
                <th style="position: sticky; left: 0; z-index: 110; min-width: 70px; width: 70px; padding: 4px 6px; text-align: center; font-weight: 600; border-right: 2px solid rgba(255,255,255,0.4); background: #1E88E5; font-size: 0.7rem;">残り</th>`;
            topTeams.forEach((team, index) => {
                const isLast = index === topTeams.length - 1;
                html += `<th colspan="2" style="min-width: 140px; width: 140px; padding: 4px; text-align: center; font-weight: 600; background: rgba(255,255,255,0.9); color: #333; ${index === 2 ? 'border-right: 4px solid #FF6B35;' : (!isLast ? 'border-right: 2px solid rgba(255,255,255,0.5);' : '')} font-size: 0.7rem;">残り: ${team.remainingGames}試合</th>`;
            });

            // Column split row
            html += `</tr><tr style="background: #1E88E5; color: white;">
                <th style="position: sticky; left: 0; z-index: 110; min-width: 70px; width: 70px; padding: 4px 6px; text-align: center; font-weight: 600; border-right: 2px solid rgba(255,255,255,0.4); background: #1E88E5; font-size: 0.7rem;">勝率</th>`;
            topTeams.forEach((team, index) => {
                const isLast = index === topTeams.length - 1;
                html += `
                    <th style="width: 70px; min-width: 70px; font-size: 0.7rem; padding: 2px 1px; background: rgba(255,255,255,0.1); border-right: 1px solid rgba(255,255,255,0.3); text-align: center; font-weight: 600;">残り成績<br><span style=\"font-size: 0.6rem;\">(勝-敗/勝率)</span></th>
                    <th style="width: 85px; min-width: 85px; font-size: 0.7rem; padding: 2px 1px; background: rgba(255,255,255,0.1); ${index === 2 ? 'border-right: 4px solid #FF6B35;' : (!isLast ? 'border-right: 2px solid rgba(255,255,255,0.5);' : '')} text-align: center; font-weight: 600;">最終成績<br><span style=\"font-size: 0.6rem;\">(勝-敗-分/勝率)</span></th>`;
            });

            html += `</tr></thead><tbody>`;

            const allScenarios = [];
            topTeams.forEach(team => {
                for (let wins = team.remainingGames; wins >= 0; wins--) {
                    const losses = team.remainingGames - wins;
                    const finalWins = team.wins + wins;
                    const finalLosses = team.losses + losses;
                    const finalWinRate = finalWins / (finalWins + finalLosses);
                    allScenarios.push({ team: team.team, wins, losses, finalWinRate, remainingWinRate: wins / (wins + losses) || 0 });
                }
            });

            const winRateGroups = {};
            allScenarios.forEach(s => {
                const key = s.finalWinRate.toFixed(3);
                (winRateGroups[key] ||= []).push(s);
            });

            Object.keys(winRateGroups).sort((a,b) => parseFloat(b) - parseFloat(a)).forEach(rateKey => {
                const scenarios = winRateGroups[rateKey];
                const winRate = parseFloat(rateKey);
                html += `<tr class="scenario-row">
                    <td style="font-size: 0.8rem; padding: 3px 2px; font-weight: 700; background: white; color: #2E7D32; border: 1px solid #dee2e6; text-align: center; position: sticky; left: 0; z-index: 5; width: 60px; box-shadow: 2px 0 4px rgba(0,0,0,0.1); line-height: 1.2;">0.${winRate.toFixed(3).split('.')[1]}</td>`;
                topTeams.forEach((team, teamIndex) => {
                    const isLast = teamIndex === topTeams.length - 1;
                    const teamScenario = scenarios.find(s => s.team === team.team);
                    if (teamScenario) {
                        const remainingWinRate = teamScenario.wins === 0 && teamScenario.losses > 0 ? 0.0 :
                                                 teamScenario.losses === 0 && teamScenario.wins > 0 ? 1.0 :
                                                 (teamScenario.wins / (teamScenario.wins + teamScenario.losses) || 0);
                        const finalWins = team.wins + teamScenario.wins;
                        const finalLosses = team.losses + teamScenario.losses;
                        const finalDraws = team.draws || 0;
                        const finalBg = getWinRateBackgroundColor(teamScenario.finalWinRate);
                        const finalFg = getWinRateTextColor(teamScenario.finalWinRate);
                        const remainBg = getWinRateBackgroundColor(remainingWinRate);
                        const remainFg = getWinRateTextColor(remainingWinRate);

                        html += `<td style="padding: 2px 0px; text-align: center; border: 1px solid #dee2e6; width: 70px; min-width: 70px; line-height: 1.1; background: ${remainBg}; color: ${remainFg};">
                            <div style="font-size: 0.8rem; font-weight: 600;">${teamScenario.wins}勝 ${teamScenario.losses}敗</div>
                            <div style="font-size: 0.7rem;">${remainingWinRate === 1.0 ? '1.000' : '0.' + remainingWinRate.toFixed(3).split('.')[1]}</div>
                        </td>`;
                        html += `<td style="padding: 2px 1px; text-align: center; border: 1px solid #dee2e6; width: 85px; min-width: 85px; line-height: 1.1; white-space: nowrap; background: ${finalBg}; color: ${finalFg}; ${teamIndex === 2 ? 'border-right: 4px solid #FF6B35;' : (!isLast ? 'border-right: 2px solid #dee2e6;' : '')}"> 
                            <div style="font-size: 0.8rem; font-weight: 600;">${finalWins}勝 ${finalLosses}敗 ${finalDraws}分</div>
                            <div style="font-size: 0.7rem;">0.${teamScenario.finalWinRate.toFixed(3).split('.')[1]}</div>
                        </td>`;
                    } else {
                        html += `<td style="background: #f8f9fa; border: 1px solid #dee2e6;"></td><td style="background: #f8f9fa; border: 1px solid #dee2e6; ${teamIndex === 2 ? 'border-right: 4px solid #FF6B35;' : (!isLast ? 'border-right: 2px solid #dee2e6;' : '')}"></td>`;
                    }
                });
                html += `</tr>`;
            });

            html += `</tbody></table></div>`;
            return html;
        }

        // V2: Same as generateScenarioMatrix but with 3位カットライン after index 2
        function generateScenarioMatrixV2(topTeams) {
            const cutoffIndex = 2; // 0-based: after 3rd place
            let html = `
                <div class="scenario-matrix-container" style="
                    overflow-x: auto; overflow-y: auto; border-radius: 12px; border: 1px solid #e0e0e0; box-shadow: 0 2px 8px rgba(0,0,0,0.1);
                    max-height: 80vh; width: 100%; position: relative;">
                    <table class="scenario-matrix-table" style="width: 100%; border-collapse: collapse; font-size: 0.75rem; background: white; min-width: ${window.innerWidth <= 768 ? '700px' : Math.max(900, 6 * (70 + 85) + 70 + 140) + 'px'};">
                        <thead style="position: sticky; top: 0; z-index: 100;">
                          <tr style="background: #1E88E5; color: white;">
                            <th style="position: sticky; left: 0; z-index: 110; min-width: 70px; width: 70px; padding: 4px 6px; text-align: center; font-weight: 600; border-right: 2px solid rgba(255,255,255,0.4); background: #1E88E5; font-size: 0.7rem;">勝率</th>`;

            // Header team columns
            topTeams.forEach((team, index) => {
                const isLast = index === topTeams.length - 1;
                const teamMeta = NPB_TEAM_META[team.team];
                const teamColor = teamMeta?.color || '#333';
                const totalColumnWidth = '140px';
                const logo = TEAM_LOGOS[team.team] ? `<img class=\"team-logo\" src=\"${TEAM_LOGOS[team.team]}\" alt=\"${teamMeta?.fullName || team.team}\" loading=\"lazy\">` : '';
                html += `<th colspan="2" style="min-width: ${totalColumnWidth}; width: ${totalColumnWidth}; padding: 6px 4px 3px 4px; text-align: center; font-weight: 700; background: #F0F2F5; color: ${teamColor}; ${index === cutoffIndex ? 'border-right: 4px solid #FF6B35;' : (!isLast ? 'border-right: 2px solid rgba(255,255,255,0.5);' : '')} font-size: 0.8rem; white-space: nowrap; line-height: 1.2;"> 
                    <div style="font-size: 0.85rem; font-weight: 800; color: ${teamColor};">${team.displayRank || team.rank}位 ${logo}${teamMeta?.shortName || team.team}</div>
                </th>`;
            });

            // Current record row
            html += `</tr><tr style="background: #1E88E5; color: white;">
                <th style="position: sticky; left: 0; z-index: 110; min-width: 70px; width: 70px; padding: 4px 6px; text-align: center; font-weight: 600; border-right: 2px solid rgba(255,255,255,0.4); background: #1E88E5; font-size: 0.7rem;">成績</th>`;
            topTeams.forEach((team, index) => {
                const isLast = index === topTeams.length - 1;
                html += `<th colspan="2" style="min-width: 140px; width: 140px; padding: 4px; text-align: center; font-weight: 600; background: rgba(255,255,255,0.9); color: #333; ${index === cutoffIndex ? 'border-right: 4px solid #FF6B35;' : (!isLast ? 'border-right: 2px solid rgba(255,255,255,0.5);' : '')} font-size: 0.7rem;">${team.wins}勝 ${team.losses}敗 ${team.draws || 0}分 (0.${(team.winRate ?? (team.wins/(team.wins+team.losses))).toFixed(3).split('.')[1]})</th>`;
            });

            // Remaining row
            html += `</tr><tr style="background: #1E88E5; color: white;">
                <th style="position: sticky; left: 0; z-index: 110; min-width: 70px; width: 70px; padding: 4px 6px; text-align: center; font-weight: 600; border-right: 2px solid rgba(255,255,255,0.4); background: #1E88E5; font-size: 0.7rem;">残り</th>`;
            topTeams.forEach((team, index) => {
                const isLast = index === topTeams.length - 1;
                html += `<th colspan="2" style="min-width: 140px; width: 140px; padding: 4px; text-align: center; font-weight: 600; background: rgba(255,255,255,0.9); color: #333; ${index === cutoffIndex ? 'border-right: 4px solid #FF6B35;' : (!isLast ? 'border-right: 2px solid rgba(255,255,255,0.5);' : '')} font-size: 0.7rem;">残り: ${team.remainingGames}試合</th>`;
            });

            // Column split row
            html += `</tr><tr style="background: #1E88E5; color: white;">
                <th style="position: sticky; left: 0; z-index: 110; min-width: 70px; width: 70px; padding: 4px 6px; text-align: center; font-weight: 600; border-right: 2px solid rgba(255,255,255,0.4); background: #1E88E5; font-size: 0.7rem;">勝率</th>`;
            topTeams.forEach((team, index) => {
                const isLast = index === topTeams.length - 1;
                html += `
                    <th style="width: 70px; min-width: 70px; font-size: 0.7rem; padding: 2px 1px; background: rgba(255,255,255,0.1); border-right: 1px solid rgba(255,255,255,0.3); text-align: center; font-weight: 600;">残り成績<br><span style=\"font-size: 0.6rem;\">(勝-敗/勝率)</span></th>
                    <th style="width: 85px; min-width: 85px; font-size: 0.7rem; padding: 2px 1px; background: rgba(255,255,255,0.1); ${index === cutoffIndex ? 'border-right: 4px solid #FF6B35;' : (!isLast ? 'border-right: 2px solid rgba(255,255,255,0.5);' : '')} text-align: center; font-weight: 600;">最終成績<br><span style=\"font-size: 0.6rem;\">(勝-敗-分/勝率)</span></th>`;
            });

            html += `</tr></thead><tbody>`;

            const allScenarios = [];
            topTeams.forEach(team => {
                for (let wins = team.remainingGames; wins >= 0; wins--) {
                    const losses = team.remainingGames - wins;
                    const finalWins = team.wins + wins;
                    const finalLosses = team.losses + losses;
                    const finalWinRate = finalWins / (finalWins + finalLosses);
                    allScenarios.push({ team: team.team, wins, losses, finalWinRate, remainingWinRate: wins / (wins + losses) || 0 });
                }
            });

            const winRateGroups = {};
            allScenarios.forEach(s => {
                const key = s.finalWinRate.toFixed(3);
                (winRateGroups[key] ||= []).push(s);
            });

            Object.keys(winRateGroups).sort((a,b) => parseFloat(b) - parseFloat(a)).forEach(rateKey => {
                const scenarios = winRateGroups[rateKey];
                const winRate = parseFloat(rateKey);
                html += `<tr class="scenario-row">
                    <td style="font-size: 0.8rem; padding: 3px 2px; font-weight: 700; background: white; color: #2E7D32; border: 1px solid #dee2e6; text-align: center; position: sticky; left: 0; z-index: 5; width: 60px; box-shadow: 2px 0 4px rgba(0,0,0,0.1); line-height: 1.2;">0.${winRate.toFixed(3).split('.')[1]}</td>`;
                topTeams.forEach((team, teamIndex) => {
                    const isLast = teamIndex === topTeams.length - 1;
                    const teamScenario = scenarios.find(s => s.team === team.team);
                    if (teamScenario) {
                        const remainingWinRate = teamScenario.wins === 0 && teamScenario.losses > 0 ? 0.0 :
                                                 teamScenario.losses === 0 && teamScenario.wins > 0 ? 1.0 :
                                                 (teamScenario.wins / (teamScenario.wins + teamScenario.losses) || 0);
                        const finalWins = team.wins + teamScenario.wins;
                        const finalLosses = team.losses + teamScenario.losses;
                        const finalDraws = team.draws || 0;
                        const finalBg = getWinRateBackgroundColor(teamScenario.finalWinRate);
                        const finalFg = getWinRateTextColor(teamScenario.finalWinRate);
                        const remainBg = getWinRateBackgroundColor(remainingWinRate);
                        const remainFg = getWinRateTextColor(remainingWinRate);

                        html += `<td style="padding: 2px 0px; text-align: center; border: 1px solid #dee2e6; width: 70px; min-width: 70px; line-height: 1.1; background: ${remainBg}; color: ${remainFg};">
                            <div style="font-size: 0.8rem; font-weight: 600;">${teamScenario.wins}勝 ${teamScenario.losses}敗</div>
                            <div style="font-size: 0.7rem;">${remainingWinRate === 1.0 ? '1.000' : '0.' + remainingWinRate.toFixed(3).split('.')[1]}</div>
                        </td>`;
                        html += `<td style="padding: 2px 1px; text-align: center; border: 1px solid #dee2e6; width: 85px; min-width: 85px; line-height: 1.1; white-space: nowrap; background: ${finalBg}; color: ${finalFg}; ${teamIndex === cutoffIndex ? 'border-right: 4px solid #FF6B35;' : (!isLast ? 'border-right: 2px solid #dee2e6;' : '')}">
                            <div style="font-size: 0.8rem; font-weight: 600;">${finalWins}勝 ${finalLosses}敗 ${finalDraws}分</div>
                            <div style="font-size: 0.7rem;">0.${teamScenario.finalWinRate.toFixed(3).split('.')[1]}</div>
                        </td>`;
                    } else {
                        html += `<td style="background: #f8f9fa; border: 1px solid #dee2e6;"></td><td style="background: #f8f9fa; border: 1px solid #dee2e6; ${teamIndex === cutoffIndex ? 'border-right: 4px solid #FF6B35;' : (!isLast ? 'border-right: 2px solid #dee2e6;' : '')}"></td>`;
                    }
                });
                html += `</tr>`;
            });

            html += `</tbody></table></div>`;
            return html;
        }

        function generateDetailedScenarios(topTeams) {
            let html = `
                <div style="margin-bottom: 15px;">
                    <h5 style="color: #2E7D32; margin-bottom: 10px;">🏆 詳細シナリオ分析</h5>
                    <p style="font-size: 0.9rem; color: #666; margin-bottom: 15px;">CS進出可能性のある全チームの残り試合の勝敗パターンと、それぞれの最終成績・勝率を表示します。</p>
                </div>
                <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px;">`;

            topTeams.forEach((team, index) => {
                const colors = ['#e3f2fd', '#e8f5e8', '#fff3e0', '#f3e5f5', '#fce4ec'];
                const bgColor = colors[index] || '#f8f9fa';
                const meta = NPB_TEAM_META[team.team] || {};
                const logo = TEAM_LOGOS[team.team] ? `<img class=\"team-logo\" src=\"${TEAM_LOGOS[team.team]}\" alt=\"${meta.fullName || team.team}\">` : '';
                html += `
                    <div style="background: ${bgColor}; border: 1px solid #dee2e6; border-radius: 8px; padding: 15px;">
                        <h6 style="margin: 0 0 10px 0; color: #333; text-align: center; font-size: 1.1rem; font-weight: bold;">${team.rank}位 ${logo}${meta.fullName || team.team}</h6>
                        <div style="text-align: center; margin-bottom: 10px; font-size: 0.9rem; color: #666;">
                            現在: ${team.wins}勝 ${team.losses}敗 ${team.draws || 0}分 0.${(team.winRate ?? (team.wins/(team.wins+team.losses))).toFixed(3).split('.')[1]}<br>
                            残り: ${team.remainingGames}試合
                        </div>
                        <table style="width: 100%; border-collapse: collapse; font-size: 0.8rem;">
                            <thead>
                                <tr style="background: rgba(0,0,0,0.05);">
                                    <th style="padding: 2px; border: 1px solid #ccc; width: 25px; text-align: center;">勝</th>
                                    <th style="padding: 2px; border: 1px solid #ccc; width: 25px; text-align: center;">敗</th>
                                    <th style="padding: 2px; border: 1px solid #ccc; width: 80px; text-align: center;">最終成績</th>
                                    <th style="padding: 2px; border: 1px solid #ccc; width: 50px; text-align: center;">最終勝率</th>
                                </tr>
                            </thead>
                            <tbody>`;

                for (let wins = team.remainingGames; wins >= 0; wins--) {
                    const losses = team.remainingGames - wins;
                    const finalWins = team.wins + wins;
                    const finalLosses = team.losses + losses;
                    const finalGames = finalWins + finalLosses + (team.draws || 0);
                    const finalWinRate = finalWins / finalGames;
                    const rowBg = getWinRateColor(finalWinRate);
                    html += `
                        <tr style="background: ${rowBg};">
                            <td style="padding: 2px; border: 1px solid #ccc; text-align: center; width: 25px;">${wins}</td>
                            <td style="padding: 2px; border: 1px solid #ccc; text-align: center; width: 25px;">${losses}</td>
                            <td style="padding: 2px; border: 1px solid #ccc; text-align: center; width: 80px; font-size: 0.75rem;">${finalWins}-${finalLosses}-${team.draws || 0}</td>
                            <td style="padding: 2px; border: 1px solid #ccc; text-align: center; font-weight: 600; width: 50px;">0.${(finalWinRate).toFixed(3).split('.')[1]}</td>
                        </tr>`;
                }

                html += `
                            </tbody>
                        </table>
                    </div>`;
            });

            html += `</div>`;
            return html;
        }

        function getWinRateColor(winRate) {
            // Light blue tones for higher win rates, light red for lower
            if (winRate >= 0.700) return '#BBDEFB';
            if (winRate >= 0.650) return '#CDE5FD';
            if (winRate >= 0.600) return '#E3F2FD';
            if (winRate >= 0.550) return '#F1F8FF';
            if (winRate >= 0.500) return '#F6FAFF';
            if (winRate >= 0.450) return '#FFECEC';
            if (winRate >= 0.400) return '#FFE3E3';
            return '#FFD9D9';
        }

        function getWinRateBackgroundColor(winRate) {
            // Solid colors for readability (no gradients)
            if (winRate > 0.5) return '#E3F2FD';   // light blue
            if (winRate < 0.5) return '#FFEBEE';   // light red
            return '#ECEFF1';                      // blue-gray for exactly .500
        }

        function getWinRateTextColor(winRate) {
            if (winRate > 0.5) return '#0D47A1';  // dark blue text on light blue
            if (winRate < 0.5) return '#C62828';  // dark red text on light red
            return '#37474F';                    // blue-gray text on neutral
        }

        // ===== 残り試合数更新 =====
        function updateRemainingGames() {
            updateRemainingMatrix('central-remaining-matrix', standingsData.central_league?.standings || [], 'central');
            updateRemainingMatrix('pacific-remaining-matrix', standingsData.pacific_league?.standings || [], 'pacific');
        }

        // ===== シーズン進行状況更新 =====
        function updateProgress() {
            updateOverallProgress();
            updateTeamProgress('central-progress', standingsData.central_league?.standings || []);
            updateTeamProgress('pacific-progress', standingsData.pacific_league?.standings || []);
            updateProgressStats();
        }

        function updateOverallProgress() {
            const allTeams = [
                ...(standingsData.central_league?.standings || []),
                ...(standingsData.pacific_league?.standings || [])
            ];
            
            if (!allTeams.length) return;
            
            // 실제 시즌 총 경기 수: 각 팀 143경기 × 12팀 ÷ 2 (각 경기는 2팀 참여)
            const totalSeasonGames = (allTeams.length * TOTAL_GAMES) / 2;  // 858경기
            
            // 현재까지 완료된 경기 수: 모든 팀의 경기 수 합계 ÷ 2
            const totalGamesPlayed = allTeams.reduce((sum, team) => sum + (team.games_played || 0), 0) / 2;
            
            const progressPercentage = (totalGamesPlayed / totalSeasonGames) * 100;
            const remainingGames = totalSeasonGames - totalGamesPlayed;
            
            // UI 업데이트
            const percentageEl = document.getElementById('overall-percentage');
            const progressFillEl = document.getElementById('overall-progress-fill');
            const completedEl = document.getElementById('completed-games');
            const remainingEl = document.getElementById('remaining-total');
            const totalEl = document.getElementById('total-season-games');
            
            if (percentageEl) percentageEl.textContent = `${progressPercentage.toFixed(1)}%`;
            if (progressFillEl) progressFillEl.style.width = `${progressPercentage}%`;
            if (completedEl) completedEl.textContent = totalGamesPlayed.toLocaleString();
            if (remainingEl) remainingEl.textContent = remainingGames.toLocaleString();
            if (totalEl) totalEl.textContent = totalSeasonGames.toLocaleString();
        }

        function updateTeamProgress(containerId, teams) {
            const container = document.getElementById(containerId);
            if (!container || !teams.length) return;
            
            let html = '';
            
            // 팀을 진행률 순으로 정렬
            const sortedTeams = teams.slice().sort((a, b) => (b.games_played || 0) - (a.games_played || 0));
            
            sortedTeams.forEach(team => {
                const gamesPlayed = team.games_played || 0;
                const progressPercentage = (gamesPlayed / TOTAL_GAMES) * 100;
                const remaining = TOTAL_GAMES - gamesPlayed;
                
                // 진행률에 따른 색상 결정
                let barColor = '#4caf50'; // 기본 초록
                if (progressPercentage < 50) {
                    barColor = '#ff9800'; // 주황
                } else if (progressPercentage < 70) {
                    barColor = '#ffeb3b'; // 노랑
                } else if (progressPercentage > 90) {
                    barColor = '#2e7d32'; // 진한 초록
                }
                
                html += `
                    <div class="team-progress-item">
                        <div class="team-progress-name">${renderTeamLabel(team.team_abbreviation, team.team_name, true)}</div>
                        <div class="team-progress-bar">
                            <div class="team-progress-fill" style="width: ${progressPercentage}%; background: ${barColor};"></div>
                        </div>
                        <div class="team-progress-text">${progressPercentage.toFixed(1)}%</div>
                    </div>
                    <div style="font-size: 13px; color: #333; margin: 2px 0 15px 8px; font-weight: 600; background: #f0f0f0; padding: 6px 12px; border-radius: 15px; display: inline-block;">
                        完了 <span style="color: #2e7d32; font-weight: 700;">${gamesPlayed}</span>試合 • 残り <span style="color: #ff5722; font-weight: 700;">${remaining}</span>試合
                    </div>
                `;
            });
            
            container.innerHTML = html;
        }

        function updateProgressStats() {
            const allTeams = [
                ...(standingsData.central_league?.standings || []),
                ...(standingsData.pacific_league?.standings || [])
            ];
            
            if (!allTeams.length) return;
            
            const progressRates = allTeams.map(team => (team.games_played || 0) / TOTAL_GAMES * 100);
            const averageProgress = progressRates.reduce((sum, rate) => sum + rate, 0) / progressRates.length;
            
            const maxProgress = Math.max(...progressRates);
            const minProgress = Math.min(...progressRates);
            
            const highestTeam = allTeams.find(team => (team.games_played || 0) / TOTAL_GAMES * 100 === maxProgress);
            const lowestTeam = allTeams.find(team => (team.games_played || 0) / TOTAL_GAMES * 100 === minProgress);
            
            const maxGames = Math.max(...allTeams.map(team => team.games_played || 0));
            const minGames = Math.min(...allTeams.map(team => team.games_played || 0));
            const progressGap = maxGames - minGames;
            
            // UI 업데이트
            const averageEl = document.getElementById('average-progress');
            const highestEl = document.getElementById('highest-team');
            const lowestEl = document.getElementById('lowest-team');
            const gapEl = document.getElementById('progress-gap');
            
            if (averageEl) averageEl.textContent = `${averageProgress.toFixed(1)}%`;
            if (highestEl) highestEl.innerHTML = renderTeamLabel(highestTeam?.team_abbreviation, highestTeam?.team_name, true) || '—';
            if (lowestEl) lowestEl.innerHTML = renderTeamLabel(lowestTeam?.team_abbreviation, lowestTeam?.team_name, true) || '—';
            if (gapEl) gapEl.textContent = `${progressGap}試合`;
        }

        // ===== 残り試合マトリクス更新（共通関数） =====
        function updateRemainingMatrix(containerId, teams, leagueType) {
            const container = document.getElementById(containerId);
            if (!teams.length) {
                container.innerHTML = '<div class="loading">データがありません</div>';
                return;
            }

            // チーム順序を順位順にソート
            const sortedTeams = [...teams].sort((a, b) => a.rank - b.rank);
            const teamCount = sortedTeams.length;

            // グリッドのカラム数を設定 (チーム名 + 各チーム + 合計)
            const gridColumns = teamCount + 2;
            container.style.gridTemplateColumns = `180px repeat(${teamCount}, 100px) 80px`;

            let matrixHTML = '';

            // ヘッダー行 - 相手チーム名 (アウェーチーム)
            matrixHTML += '<div class="matrix-cell matrix-corner">ホーム＼アウェー</div>';
            sortedTeams.forEach(team => {
                const teamLabel = renderTeamLabel(team.team_abbreviation, team.team_name, true);
                matrixHTML += `<div class="matrix-cell matrix-header-opponent">${teamLabel}</div>`;
            });
            matrixHTML += '<div class="matrix-cell matrix-corner">合計</div>';

            // 残り試合マトリクスデータを構築
            const matrixData = {};
            if (upcomingGamesData && Array.isArray(upcomingGamesData)) {
                upcomingGamesData.forEach(game => {
                    if (game.game_status !== 'scheduled') return;
                    
                    const homeAbbr = game.home_team_abbr;
                    const awayAbbr = game.away_team_abbr;
                    
                    if (!matrixData[homeAbbr]) matrixData[homeAbbr] = {};
                    if (!matrixData[homeAbbr][awayAbbr]) matrixData[homeAbbr][awayAbbr] = 0;
                    matrixData[homeAbbr][awayAbbr]++;
                });
            }

            // データ行
            sortedTeams.forEach(homeTeam => {
                // チーム名（ホーム）
                const teamLabel = renderTeamLabel(homeTeam.team_abbreviation, homeTeam.team_name, true);
                matrixHTML += `<div class="matrix-cell matrix-header-team">${teamLabel}</div>`;

                let rowTotal = 0;

                // 各相手チームとの対戦数
                sortedTeams.forEach(awayTeam => {
                    if (homeTeam.team_abbreviation === awayTeam.team_abbreviation) {
                        // 自チーム
                        matrixHTML += '<div class="matrix-cell matrix-data-cell" style="background: #f5f5f5; color: #999;">-</div>';
                    } else {
                        // 残り試合数を取得
                        const remainingGames = matrixData[homeTeam.team_abbreviation]?.[awayTeam.team_abbreviation] || 0;
                        
                        const cellClass = remainingGames > 0 ? 'has-games' : 'zero';
                        matrixHTML += `<div class="matrix-cell matrix-data-cell ${cellClass}">${remainingGames}</div>`;
                        rowTotal += remainingGames;
                    }
                });

                // 行の合計（ホーム試合数）
                matrixHTML += `<div class="matrix-cell matrix-total-cell">${rowTotal}</div>`;
            });

            // 最終行: 各列の合計（アウェー試合数）
            matrixHTML += '<div class="matrix-cell matrix-corner">合計</div>';
            sortedTeams.forEach(awayTeam => {
                let columnTotal = 0;
                sortedTeams.forEach(homeTeam => {
                    if (homeTeam.team_abbreviation !== awayTeam.team_abbreviation) {
                        columnTotal += matrixData[homeTeam.team_abbreviation]?.[awayTeam.team_abbreviation] || 0;
                    }
                });
                matrixHTML += `<div class="matrix-cell matrix-total-cell">${columnTotal}</div>`;
            });
            
            // 総合計
            let grandTotal = 0;
            sortedTeams.forEach(team => {
                grandTotal += TOTAL_GAMES - team.games_played;
            });
            matrixHTML += `<div class="matrix-cell matrix-corner" style="font-weight: bold;">${Math.floor(grandTotal/2)}</div>`;

            container.innerHTML = matrixHTML;
        }

        // ===== エラー表示機能 =====
        function showError(errorMsg = 'データ読み込みに失敗しました') {
            const errorHtml = `<tr><td colspan="15" class="loading">❌ ${errorMsg}</td></tr>`;
            document.querySelectorAll('tbody').forEach(tbody => {
                tbody.innerHTML = errorHtml;
            });
            
            // 에러 상세 정보 표시
            const errorDetail = document.createElement('div');
            errorDetail.style.cssText = 'position: fixed; top: 10px; right: 10px; background: #ffebee; color: #c62828; padding: 10px; border: 1px solid #e57373; border-radius: 4px; z-index: 1000; max-width: 300px;';
            errorDetail.innerHTML = `
                <strong>エラー詳細:</strong><br>
                ${errorMsg}<br>
                <small>ブラウザのコンソール(F12)で詳細を確認してください</small>
                <button onclick="this.parentNode.remove()" style="float: right; margin-left: 10px;">×</button>
            `;
            document.body.appendChild(errorDetail);
            
            // 5秒 후 자동 제거
            setTimeout(() => {
                if (errorDetail.parentNode) {
                    errorDetail.remove();
                }
            }, 5000); // 5秒後に自動除去
        }
        
        // ===== データパス取得（GitHub Pages対応） =====
        function getDataPath() {
            const hostname = window.location.hostname;
            const isGitHubPages = hostname.endsWith('.github.io') || hostname.includes('github');
            
            if (isGitHubPages) {
                // GitHub Pages: 절대 경로 사용
                const basePath = window.location.pathname.replace('/index.html', '').replace('/', '');
                return basePath ? `/${basePath}/data/standings.json` : '/data/standings.json';
            } else {
                // 로컬: 상대 경로 사용  
                return './data/standings.json';
            }
        }
        
        // ===== データ型正規化処理 =====
        function normalizeStandingsData(data) {
            if (!data) return data;
            
            // 각 리그의 팀 데이터 정규화
            ['central_league', 'pacific_league'].forEach(league => {
                if (data[league]?.standings) {
                    data[league].standings = data[league].standings.map(team => ({
                        ...team,
                        // 문자열을 숫자로 변환
                        win_percentage: parseFloat(team.win_percentage) || 0,
                        games_behind: parseFloat(team.games_behind) || 0,
                        wins: parseInt(team.wins) || 0,
                        losses: parseInt(team.losses) || 0,
                        draws: parseInt(team.draws) || 0,
                        games_played: parseInt(team.games_played) || 0,
                        runs_scored: parseInt(team.runs_scored) || 0,
                        runs_allowed: parseInt(team.runs_allowed) || 0,
                        run_differential: parseInt(team.run_differential) || 0
                    }));
                }
            });
            
            return data;
        }
        
        // ===== Home/Away 잔여 계산 (실제 스케줄 데이터 사용) =====
        function computeHomeAwayRemaining() {
            homeAwayRemainingByTeam = {};
            if (!standingsData) return;

            const allTeams = [...(standingsData.central_league?.standings || []), ...(standingsData.pacific_league?.standings || [])];
            const teamIds = allTeams.map(t => t.team_id);

            // 기본값: 0으로 초기화
            teamIds.forEach(id => { homeAwayRemainingByTeam[id] = { home: 0, away: 0, opponents: {} }; });

            // 실제 스케줄 데이터가 있으면 사용
            if (upcomingGamesData && Array.isArray(upcomingGamesData)) {
                upcomingGamesData.forEach(game => {
                    if (game.game_status !== 'scheduled') return;
                    
                    const homeId = game.home_team_id;
                    const awayId = game.away_team_id;
                    
                    // 홈팀 잔여 홈 게임 증가
                    if (homeAwayRemainingByTeam[homeId]) {
                        homeAwayRemainingByTeam[homeId].home++;
                        // 상대팀 정보 추가
                        const opponentAbbr = game.away_team_abbr;
                        homeAwayRemainingByTeam[homeId].opponents[opponentAbbr] = (homeAwayRemainingByTeam[homeId].opponents[opponentAbbr] || 0) + 1;
                    }
                    
                    // 원정팀 잔여 원정 게임 증가
                    if (homeAwayRemainingByTeam[awayId]) {
                        homeAwayRemainingByTeam[awayId].away++;
                        // 상대팀 정보 추가
                        const opponentAbbr = game.home_team_abbr;
                        homeAwayRemainingByTeam[awayId].opponents[opponentAbbr] = (homeAwayRemainingByTeam[awayId].opponents[opponentAbbr] || 0) + 1;
                    }
                });
            } else {
                // 스케줄 데이터가 없으면 균등 분배로 폴백
                allTeams.forEach(t => {
                    const remaining = Math.max(0, TOTAL_GAMES - t.games_played);
                    const home = Math.floor(remaining / 2);
                    const away = remaining - home;
                    homeAwayRemainingByTeam[t.team_id] = { home, away, opponents: {} };
                });
            }
        }

        // ===== メインデータ読み込み処理 =====
        async function loadDataEnhanced() {
            try {
                
                // 순위 데이터 로딩 (cache-busting)
                const basePath = getDataPath();
                const cacheBust = `v=${Date.now()}`;
                const dataUrl = basePath + (basePath.includes('?') ? '&' : '?') + cacheBust;
                const response = await fetch(dataUrl, { cache: 'no-store' });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${dataPath}`);
                }
                
                const rawData = await response.json();
                
                // 시즌 설정 데이터 로딩 (dashboard.json, cache-busting 동일 적용)
                try {
                    const dashboardBase = basePath.replace('standings.json', 'dashboard.json');
                    const dashboardUrl = dashboardBase + (dashboardBase.includes('?') ? '&' : '?') + cacheBust;
                    const dashboardResponse = await fetch(dashboardUrl, { cache: 'no-store' });
                    if (dashboardResponse.ok) {
                        seasonConfig = await dashboardResponse.json();
                        // NPB 정규시즌은 팀당 143試合. 대시보드가 있더라도 TOTAL_GAMES는 143으로 고정.
                        if (seasonConfig.season_stats) {
                            const allTeams = [...(rawData.central_league?.standings || []), ...(rawData.pacific_league?.standings || [])];
                            const maxGamesPlayed = Math.max(...allTeams.map(t => t.games_played));
                            TOTAL_GAMES = 143;
                        }
                    }
                } catch (dashboardError) {
                    // ダッシュボードデータなし、デフォルト値使用
                }
                
                // 경기 데이터 로딩 (home/away 잔여 계산용)
                try {
                    const gamesBase = basePath.replace('standings.json', 'games.json');
                    const gamesUrl = gamesBase + (gamesBase.includes('?') ? '&' : '?') + cacheBust;
                    const gamesResp = await fetch(gamesUrl, { cache: 'no-store' });
                    if (gamesResp.ok) {
                        gamesData = await gamesResp.json();
                    }
                } catch (gamesError) {}

                // 잔여 경기 데이터 로딩
                try {
                    const upcomingBase = basePath.replace('standings.json', 'upcoming.json');
                    const upcomingUrl = upcomingBase + (upcomingBase.includes('?') ? '&' : '?') + cacheBust;
                    const upcomingResp = await fetch(upcomingUrl, { cache: 'no-store' });
                    if (upcomingResp.ok) {
                        upcomingGamesData = await upcomingResp.json();
                    }
                } catch (upcomingError) {}

                // 데이터 타입 정규화
                standingsData = normalizeStandingsData(rawData);

                if (standingsData.updated_at) {
                    const updated = new Date(standingsData.updated_at).toLocaleString('ja-JP', {
                        timeZone: 'Asia/Tokyo', year: 'numeric', month: '2-digit', day: '2-digit',
                        hour: '2-digit', minute: '2-digit', second: '2-digit'
                    });
                    const lastEl = document.getElementById('last-update');
                    if (lastEl) lastEl.textContent = `${updated} JST`;
                }

                // Initialize schedule view with Today
                initScheduleToggle();

                // 실제 통계 데이터 표시
                if (seasonConfig && seasonConfig.season_stats) {
                    const stats = seasonConfig.season_stats;
                    if (typeof stats.total_games === 'number') {
                        document.getElementById('total-games').textContent = `${stats.total_games}試合`;
                    }
                    // 오늘 경기 수는 헤더(今日の試合) 옆에만 표기
                    // dashboard의 today_games는 무시 - 실제 계산값 사용
                }
                
                computeHomeAwayRemaining();
                updateMagicRegular();
                updateMagicPlayoff();
                updateScenarios();
                updateDetailedStandings();
                updateRemainingGames();
                updateProgress();
                // Initialize '経路の数' sub-views (matrix/detailed/table) and default to matrix
                bindScenarioViewToggles();
                setScenarioView('central','matrix');
                setScenarioView('pacific','matrix');
                
            } catch (error) {
                showError(`データ読み込みエラー: ${error.message}`);
            }
        }
        
        // ===== ページ状態の保存と復元 =====
        function savePageState() {
            // スクロール位置を保存
            sessionStorage.setItem('npb-scroll-position', window.scrollY.toString());
        }

        function restorePageState() {
            // 保存されたタブがあれば復元
            const savedTab = sessionStorage.getItem('npb-current-tab');
            if (savedTab) {
                const tabElement = document.querySelector(`[data-tab="${savedTab}"]`);
                if (tabElement) {
                    showTab(savedTab, tabElement);
                }
            }

            // 保存されたスクロール位置があれば復元
            const savedScrollPosition = sessionStorage.getItem('npb-scroll-position');
            if (savedScrollPosition) {
                const scrollPosition = parseInt(savedScrollPosition, 10);
                // DOMが完全に読み込まれた後にスクロール
                setTimeout(() => {
                    window.scrollTo(0, scrollPosition);
                }, 100);
            }
        }

        // スクロール位置を定期的に保存
        let scrollSaveTimer;
        window.addEventListener('scroll', () => {
            clearTimeout(scrollSaveTimer);
            scrollSaveTimer = setTimeout(savePageState, 200);
        });

        // ページ離脱時に状態を保存
        window.addEventListener('beforeunload', savePageState);

        // Handle browser back/forward buttons
        window.addEventListener('hashchange', () => {
            const hash = window.location.hash.slice(1);
            const validTabs = ['magic-regular', 'magic-playoff', 'progress', 'scenarios', 'standings', 'remaining'];
            if (hash && validTabs.includes(hash)) {
                showTab(hash);
            }
        });

        document.addEventListener('DOMContentLoaded', () => {
            // Restore tab from URL hash
            const hash = window.location.hash.slice(1); // Remove #
            const validTabs = ['magic-regular', 'magic-playoff', 'progress', 'scenarios', 'standings', 'remaining'];

            if (hash && validTabs.includes(hash)) {
                showTab(hash);
            } else {
                // Default to first tab
                showTab('magic-regular');
            }

            loadDataEnhanced();
            restorePageState();
        });
        window.reloadData = loadDataEnhanced;

        // ===== 今日/明日の試合描画 =====
        function formatJSTDateISO(date = new Date()) {
            // Returns YYYY-MM-DD in Asia/Tokyo
            return new Intl.DateTimeFormat('en-CA', {
                timeZone: 'Asia/Tokyo', year: 'numeric', month: '2-digit', day: '2-digit'
            }).format(date);
        }

        // (Removed) JS-driven footer logic. Footer is now static HTML-only.
        function getJSTDate(offsetDays = 0) {
            // Compute date in JST adding offset days
            const now = new Date();
            const ts = now.getTime() + offsetDays * 24 * 60 * 60 * 1000;
            return new Date(ts);
        }

        let currentScheduleMode = 'today';
        function initScheduleToggle() {
            const btnToday = document.getElementById('btn-today');
            const btnTomorrow = document.getElementById('btn-tomorrow');

            btnToday?.addEventListener('click', () => setScheduleDate('today'));
            btnTomorrow?.addEventListener('click', () => setScheduleDate('tomorrow'));

            // Pick smart default: if no games today (or late night), show tomorrow when available
            const defaultMode = getDefaultScheduleMode();
            setScheduleDate(defaultMode);

            // Enable swipe/keyboard/scroll gestures to flip day
            enableScheduleGestures();

            // Auto-refresh upcoming schedule every 5 minutes
            startScheduleAutoRefresh();
        }

        function getDefaultScheduleMode() {
            try {
                const todayIso = formatJSTDateISO(getJSTDate(0));
                const tomorrowIso = formatJSTDateISO(getJSTDate(1));
                const todayGames = (upcomingGamesData || []).filter(g => g.game_status === 'scheduled' && g.game_date === todayIso);
                const tomorrowGames = (upcomingGamesData || []).filter(g => g.game_status === 'scheduled' && g.game_date === tomorrowIso);
                const hourJST = parseInt(new Date().toLocaleString('ja-JP', { timeZone: 'Asia/Tokyo', hour12: false, hour: '2-digit' }), 10);
                if ((!todayGames.length && tomorrowGames.length) || hourJST >= 23) return 'tomorrow';
            } catch (_) {}
            return 'today';
        }

        function enableScheduleGestures() {
            const section = document.getElementById('today-section');
            if (!section) return;

            // Touch swipe left/right
            let touchStartX = null;
            section.addEventListener('touchstart', (e) => {
                touchStartX = e.touches?.[0]?.clientX ?? null;
            }, { passive: true });
            section.addEventListener('touchend', (e) => {
                if (touchStartX == null) return;
                const endX = e.changedTouches?.[0]?.clientX ?? touchStartX;
                const dx = endX - touchStartX;
                if (dx < -40) setScheduleDate('tomorrow');
                else if (dx > 40) setScheduleDate('today');
                touchStartX = null;
            });

            // Keyboard arrows
            document.addEventListener('keydown', (e) => {
                if (e.key === 'ArrowRight') setScheduleDate('tomorrow');
                else if (e.key === 'ArrowLeft') setScheduleDate('today');
            });

            // Mouse/trackpad horizontal scroll flips day
            section.addEventListener('wheel', (e) => {
                if (Math.abs(e.deltaX) > Math.abs(e.deltaY) && Math.abs(e.deltaX) > 20) {
                    if (e.deltaX > 0) setScheduleDate('tomorrow');
                    else setScheduleDate('today');
                }
            }, { passive: true });
        }

        function startScheduleAutoRefresh() {
            // Refresh data periodically to reflect game status changes
            setInterval(async () => {
                try {
                    const basePath = getDataPath();
                    const upcomingBase = basePath.replace('standings.json', 'upcoming.json');
                    const cacheBust = `v=${Date.now()}`;
                    const upcomingUrl = upcomingBase + (upcomingBase.includes('?') ? '&' : '?') + cacheBust;
                    const resp = await fetch(upcomingUrl, { cache: 'no-store' });
                    if (resp.ok) {
                        upcomingGamesData = await resp.json();
                        setScheduleDate(currentScheduleMode); // re-render current mode
                    }
                } catch (_) {}
            }, 5 * 60 * 1000);
        }

        function setScheduleDate(mode) {
            const btnToday = document.getElementById('btn-today');
            const btnTomorrow = document.getElementById('btn-tomorrow');

            btnToday?.classList.toggle('active', mode === 'today');
            btnTomorrow?.classList.toggle('active', mode === 'tomorrow');

            const offset = mode === 'tomorrow' ? 1 : 0;
            const targetDate = formatJSTDateISO(getJSTDate(offset));
            currentScheduleMode = mode;
            updateScheduleForDate(targetDate, mode === 'today');
        }

        function tryFormatStartTime(g, upcomingData = null, dateIso = null) {
            const rawKeys = [
                'start_time', 'scheduled_time', 'start_time_local', 'first_pitch_time', 'game_time', 'scheduled_start_time'
            ];
            let val = undefined;
            for (const k of rawKeys) {
                if (g && g[k]) { val = g[k]; break; }
            }
            
            // 완료된 경기에 시간이 없으면 upcoming 데이터에서 찾기
            if (!val && upcomingData && dateIso) {
                const homeId = g.home_team_id;
                const awayId = g.away_team_id;
                if (homeId && awayId) {
                    const upcomingGame = upcomingData.find(ug => {
                        if (ug.game_date !== dateIso) return false;
                        const ugHomeId = ug.home_team_id;
                        const ugAwayId = ug.away_team_id;
                        return (homeId === ugHomeId && awayId === ugAwayId) || 
                               (homeId === ugAwayId && awayId === ugHomeId);
                    });
                    if (upcomingGame) {
                        val = upcomingGame.scheduled_time;
                    }
                }
            }
            
            if (!val) return null;
            try {
                if (typeof val === 'string' && val.includes('T')) {
                    const d = new Date(val);
                    if (!isNaN(d.getTime())) {
                        return d.toLocaleTimeString('ja-JP', { timeZone: 'Asia/Tokyo', hour12: false, hour: '2-digit', minute: '2-digit' });
                    }
                }
                // HH:MM or other plain time strings (전각 콜론을 반각으로 변환)
                if (typeof val === 'string') {
                    return val.replace('：', ':');
                }
            } catch (_) {}
            return null;
        }

        const DEFAULT_STADIUM_BY_HOME = {
            YOG: '東京ドーム',
            HAN: '阪神甲子園球場',
            CHU: 'バンテリンドーム ナゴヤ',
            YDB: '横浜スタジアム',
            HIR: 'MAZDA Zoom-Zoom スタジアム広島',
            YAK: '明治神宮野球場',
            SOF: '福岡PayPayドーム',
            LOT: 'ZOZOマリンスタジアム',
            SEI: 'ベルーナドーム',
            ORI: '京セラドーム大阪',
            NIP: 'エスコンフィールドHOKKAIDO',
            RAK: '楽天モバイルパーク宮城'
        };

        function tryGetVenue(g) {
            const keys = ['venue', 'stadium', 'ballpark', 'stadium_name', 'venue_name'];
            for (const k of keys) {
                if (g && g[k]) return g[k];
            }
            // fallback by home team abbreviation
            if (g?.home_team_abbr && DEFAULT_STADIUM_BY_HOME[g.home_team_abbr]) {
                return `${DEFAULT_STADIUM_BY_HOME[g.home_team_abbr]} (推定)`;
            }
            return null;
        }

        function inferStartTimeJST(dateIso) {
            // Basic heuristic: Weekday 18:00, Weekend 14:00 (JST)
            const d = new Date(`${dateIso}T00:00:00+09:00`);
            const dow = d.getUTCDay(); // 0 Sun .. 6 Sat (for +09:00 anchor)
            return (dow === 0 || dow === 6) ? '14:00' : '18:00';
        }

        function updateScheduleForDate(dateIso, updateInfoCount = false) {
            const container = document.getElementById('today-games-container');
            const dateLabel = document.getElementById('today-date');
            const displayDate = `(${dateIso.replace(/-/g, '/')})`;
            dateLabel.textContent = displayDate;

            // 예정된 경기 데이터
            const upcomingTodayGames = (upcomingGamesData || []).filter(g =>
                g.game_status === 'scheduled' && g.game_date === dateIso
            );
            
            // 완료된 경기 데이터 (games.json에서 가져오기) - 중복 제거 및 최종 스코어 선택
            const completedTodayGames = [];
            const completedGameKeys = new Set();
            const gameGroups = {};
            
            // 같은 경기끼리 그룹화
            (gamesData || []).forEach(g => {
                const gameDate = g.date || g.game_date;
                const gameStatus = g.status || g.game_status || 'scheduled';
                const isCompleted = gameDate === dateIso && gameStatus === 'completed';
                
                if (isCompleted) {
                    const homeId = g.home_team_id;
                    const awayId = g.away_team_id;
                    if (homeId && awayId) {
                        const teamIds = [homeId, awayId].sort();
                        const key = `${teamIds[0]}-${teamIds[1]}`;
                        
                        if (!gameGroups[key]) {
                            gameGroups[key] = [];
                        }
                        gameGroups[key].push(g);
                    }
                }
            });
            
            // 각 그룹에서 최종 스코어(가장 높은 스코어 합계) 선택
            Object.keys(gameGroups).forEach(key => {
                const games = gameGroups[key];
                const finalGame = games.reduce((latest, current) => {
                    const latestTotal = (latest.home_score || 0) + (latest.away_score || 0);
                    const currentTotal = (current.home_score || 0) + (current.away_score || 0);
                    return currentTotal >= latestTotal ? current : latest;
                });
                
                completedGameKeys.add(key);
                completedTodayGames.push(finalGame);
                
            });

            // 완료된 경기 필터링
            const filteredCompletedGames = completedTodayGames;
            
            // 예정된 경기에서 완료된 경기와 중복되는 것 제거
            const filteredUpcomingGames = upcomingTodayGames.filter(g => {
                const homeId = g.home_team_id;
                const awayId = g.away_team_id;
                if (!homeId || !awayId) return true;
                
                const teamIds = [homeId, awayId].sort();
                const key = `${teamIds[0]}-${teamIds[1]}`;
                
                // 예정 경기는 완료된 경기와 중복 시 제외
                return !completedGameKeys.has(key);
            });
            
            const allTodayGames = [...filteredCompletedGames, ...filteredUpcomingGames];
            
            
            // 경기 카운트 표시 강제 업데이트
            const countElement = document.getElementById('today-count');
            if (countElement && updateInfoCount) {
                countElement.textContent = `(${allTodayGames.length}試合)`;
            }

            if (!allTodayGames.length) {
                // 데이터 로딩 상태인지 확인
                if (!gamesData && !upcomingGamesData) {
                    container.innerHTML = '<div class="game-card"><div class="game-row" style="color:#888;">📊 データ読み込み中...</div></div>';
                } else {
                    // 실제로 경기가 없는 경우
                    const dayOfWeek = new Date(`${dateIso}T00:00:00+09:00`).getDay();
                    const isWeekend = dayOfWeek === 0 || dayOfWeek === 6; // Sunday or Saturday
                    
                    if (isWeekend) {
                        container.innerHTML = '<div class="game-card"><div class="game-row" style="color:#666;">⚾ 本日は試合予定がありません</div></div>';
                    } else {
                        container.innerHTML = '<div class="game-card"><div class="game-row" style="color:#666;">📅 本日の試合はお休みです</div></div>';
                    }
                }
                if (updateInfoCount) { const tc = document.getElementById('today-count'); if (tc) tc.textContent = ''; }
                return;
            }

            allTodayGames.sort((a, b) => {
                // 실제 데이터가 수집된 경기를 먼저 표시
                const aHasData = a.home_score !== null && a.home_score !== undefined && a.away_score !== null && a.away_score !== undefined;
                const bHasData = b.home_score !== null && b.home_score !== undefined && b.away_score !== null && b.away_score !== undefined;
                
                if (aHasData && !bHasData) return -1;
                if (!aHasData && bHasData) return 1;
                
                const aLeague = a.league || (a.home_team_abbr && getTeamLeague(a.home_team_abbr)) || 'Unknown';
                const bLeague = b.league || (b.home_team_abbr && getTeamLeague(b.home_team_abbr)) || 'Unknown';
                
                if (aLeague === bLeague) {
                    const aTeams = (a.home_team_abbr || '') + (a.away_team_abbr || '');
                    const bTeams = (b.home_team_abbr || '') + (b.away_team_abbr || '');
                    return aTeams.localeCompare(bTeams);
                }
                return aLeague.localeCompare(bLeague);
            });

            if (updateInfoCount) {
                const tc = document.getElementById('today-count');
                if (tc) tc.textContent = `(${allTodayGames.length}試合)`;
            }

            container.innerHTML = allTodayGames.map(g => {
                const aLeague = g.league || (g.home_team_abbr && getTeamLeague(g.home_team_abbr)) || 'Unknown';
                const leagueClass = aLeague === 'Central' ? 'league-central' : 'league-pacific';
                
                // 경기 상태 판단 (status 필드만 사용)
                const gameStatus = g.status || g.game_status || 'scheduled';
                
                let status, statusColor;
                if (gameStatus === 'completed') {
                    status = '終了';
                    statusColor = '#d32f2f';
                } else if (gameStatus === 'postponed') {
                    status = '延期';
                    statusColor = '#f57c00';
                } else {
                    status = '予定';
                    statusColor = '#666';
                }
                
                const timeRaw = tryFormatStartTime(g, upcomingGamesData, dateIso);
                const timeStr = timeRaw || `${inferStartTimeJST(dateIso)}(推定)`;
                const venue = tryGetVenue(g) || '';
                const meta = [timeStr, venue].filter(v => v && v !== 'null' && v !== 'undefined').join(' / ');
                
                // 실제 경기 데이터가 수집되었는지 확인
                const hasGameData = g.home_score !== null && g.home_score !== undefined && g.away_score !== null && g.away_score !== undefined;
                
                // 경기 표시 형식 결정
                let statusMessage = '';
                let gameDisplay = '';
                
                if (gameStatus === 'completed' && hasGameData) {
                    // 완료된 경기만 결과 표시
                    statusMessage = '試合終了';
                    
                    const isDraw = g.is_draw || g.home_score === g.away_score;
                    const awayWin = g.away_score > g.home_score;
                    const homeWin = g.home_score > g.away_score;
                    
                    let awayTeamStyle = '';
                    let homeTeamStyle = '';
                    let scoreColor = '#d32f2f';
                    
                    if (isDraw) {
                        awayTeamStyle = 'font-weight:normal;';
                        homeTeamStyle = 'font-weight:normal;';
                        scoreColor = '#888';
                    } else if (awayWin) {
                        awayTeamStyle = 'font-weight:bold; color:#2e7d32;';
                        homeTeamStyle = 'font-weight:normal; color:#666;';
                    } else if (homeWin) {
                        awayTeamStyle = 'font-weight:normal; color:#666;';
                        homeTeamStyle = 'font-weight:bold; color:#2e7d32;';
                    }
                    
                    const inningBadge = (g.final_inning && Number.isFinite(g.final_inning))
                        ? `<span style="color:#555; font-size:11px; margin-left:6px;">(${g.final_inning}回)</span>`
                        : '';
                    gameDisplay = `
                        <span style="${awayTeamStyle}">${renderTeamLabel(g.away_team_abbr, g.away_team_name || g.away_team, true)}</span>
                        <span style="color:${scoreColor}; font-weight:bold; margin:0 6px;">${g.away_score}-${g.home_score}</span>
                        <span style="${homeTeamStyle}">${renderTeamLabel(g.home_team_abbr, g.home_team_name || g.home_team, true)}</span>
                        ${inningBadge}
                    `;
                } else {
                    // 완료되지 않은 경기: 예정 또는 특수 상태로 표시
                    if (gameStatus === 'postponed') {
                        statusMessage = '延期';
                    } else if (gameStatus === 'cancelled') {
                        statusMessage = '中止';
                    } else {
                        statusMessage = '予定';
                    }
                    
                    gameDisplay = `
                        <span>${renderTeamLabel(g.away_team_abbr, g.away_team_name || g.away_team, true)}</span>
                        <span style="color:#888; margin:0 6px; font-weight:normal;">vs</span>
                        <span>${renderTeamLabel(g.home_team_abbr, g.home_team_name || g.home_team, true)}</span>
                    `;
                }
                
                return `
                    <div class="game-card">
                        <div class="game-row">
                            <span class="league-tag ${leagueClass}">${aLeague}</span>
                            <span style="margin-left:auto; font-size:11px; color:${statusColor}; font-weight:${gameStatus === 'completed' ? 'bold' : 'normal'};">${statusMessage}</span>
                        </div>
                        <div class="game-row" style="margin-top:2px;">
                            ${gameDisplay}
                        </div>
                        ${meta ? `<div class="game-sub" style="color:#777;">${meta}</div>` : ''}
                    </div>
                `;
            }).join('');
        }

        // 팀 약자로 리그 판단하는 헬퍼 함수
        function getTeamLeague(teamAbbr) {
            // Use canonical abbreviations (YOG, HAN, CHU, YDB, HIR, YAK)
            const centralTeams = ['YOG', 'HAN', 'CHU', 'YDB', 'HIR', 'YAK'];
            const pacificTeams = ['SOF', 'LOT', 'SEI', 'ORI', 'NIP', 'RAK'];
            
            if (centralTeams.includes(teamAbbr)) return 'Central';
            if (pacificTeams.includes(teamAbbr)) return 'Pacific';
            return 'Unknown';
        }

        // ===== 언어 변환 기능 =====
        let currentLanguage = 'ja';
        
        // 현재 언어 초기화 (localStorage에서 읽기)
        function initLanguage() {
            const savedLang = localStorage.getItem('npb-language');
            if (savedLang && translations[savedLang]) {
                currentLanguage = savedLang;
            }
            updateLanguage();
            updateActiveLanguageButton();
        }
        
        // 언어 변경 함수
        function changeLanguage(lang) {
            if (!translations[lang]) return;
            
            currentLanguage = lang;
            localStorage.setItem('npb-language', lang);
            updateLanguage();
            updateActiveLanguageButton();
            
            // 메타 태그도 업데이트
            updateMetaTags(lang);
        }
        
        // 텍스트 업데이트 함수
        function updateLanguage() {
            // 일반 텍스트 번역
            const elements = document.querySelectorAll('[data-i18n]');
            elements.forEach(element => {
                const key = element.getAttribute('data-i18n');
                if (translations[currentLanguage] && translations[currentLanguage][key]) {
                    element.textContent = translations[currentLanguage][key];
                }
            });
            
            // HTML 콘텐츠 번역 (도움말 등)
            const htmlElements = document.querySelectorAll('[data-i18n-html]');
            htmlElements.forEach(element => {
                const key = element.getAttribute('data-i18n-html');
                if (translations[currentLanguage] && translations[currentLanguage][key]) {
                    element.innerHTML = translations[currentLanguage][key];
                }
            });
        }
        
        // 언어 버튼 활성화 상태 업데이트
        function updateActiveLanguageButton() {
            document.querySelectorAll('.lang-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.getAttribute('data-lang') === currentLanguage) {
                    btn.classList.add('active');
                }
            });
        }
        
        // 메타 태그 업데이트 (SEO용)
        function updateMetaTags(lang) {
            const titleMap = {
                'ja': '【毎日自動更新】NPB 2025順位表・マジックナンバー・クリンチ・CS進出確率・優勝予想 | プロ野球データベース',
                'ko': '【매일 자동 업데이트】NPB 2025 순위표·매직넘버·클린치·CS진출확률·우승예상 | 프로야구 데이터베이스',
                'en': '【Daily Auto-Update】NPB 2025 Standings・Magic Numbers・Clinch・CS Playoff Probability・Championship Prediction | Baseball Database'
            };
            
            const descriptionMap = {
                'ja': '【2025年最新】NPB順位表・マジックナンバー・クリンチ・CS進出確率・優勝予想を毎日自動更新。セリーグ・パリーグ全12球団の勝率分析、残り試合数、プレーオフシナリオまで完全網羅。巨人・阪神・ソフトバンクなど全チーム対応。',
                'ko': '【2025년 최신】NPB 순위표·매직넘버·클린치·CS진출확률·우승예상을 매일 자동업데이트. 센트럴·퍼시픽리그 전12구단의 승률분석, 남은경기수, 플레이오프 시나리오까지 완전망라. 자이언츠·타이거스·호크스 등 전팀 지원.',
                'en': '【2025 Latest】Daily auto-update of NPB standings, magic numbers, clinch, CS playoff probability, championship predictions. Complete coverage of all 12 teams from Central & Pacific leagues including win rate analysis, remaining games, playoff scenarios. Giants, Tigers, Hawks and all teams supported.'
            };
            
            // Title 업데이트
            if (titleMap[lang]) {
                document.title = titleMap[lang];
            }
            
            // Description 업데이트  
            const metaDesc = document.querySelector('meta[name="description"]');
            if (metaDesc && descriptionMap[lang]) {
                metaDesc.setAttribute('content', descriptionMap[lang]);
            }
            
            // HTML lang 속성 업데이트
            document.documentElement.setAttribute('lang', lang);
        }
        
        // 동적 콘텐츠 번역 유틸리티 함수
        function getTranslation(key) {
            return translations[currentLanguage] && translations[currentLanguage][key] ? 
                   translations[currentLanguage][key] : key;
        }
        
        // 조건 메시지 번역 함수
        function translateCondition(condition) {
            if (!condition) return condition;
            
            // 정규표현식을 사용하여 동적 메시지 번역
            if (condition.includes('勝必要')) {
                const match = condition.match(/(\d+)勝必要/);
                if (match) {
                    return `${match[1]} ${getTranslation('wins-needed')}`;
                }
            }
            
            if (condition.includes('CS進出まで') && condition.includes('勝')) {
                const match = condition.match(/CS進出まで(\d+)勝/);
                if (match) {
                    return `${match[1]} ${getTranslation('wins-needed')} for CS`;
                }
            }
            
            // 고정 메시지 번역
            const conditionMap = {
                '確定': getTranslation('championship-secured'),
                '優勝確定済み': getTranslation('championship-secured'),
                'CS進出確定': getTranslation('playoff-advancement-secured'),
                'ファイナル直行': currentLanguage === 'ja' ? 'ファイナル直行' : 
                               currentLanguage === 'ko' ? '파이널 직행' : 'Final Direct',
                'ファーストステージ': currentLanguage === 'ja' ? 'ファーストステージ' :
                                   currentLanguage === 'ko' ? '퍼스트 스테이지' : 'First Stage',
                '不可能': currentLanguage === 'ja' ? '不可能' :
                         currentLanguage === 'ko' ? '불가능' : 'Impossible'
            };
            
            return conditionMap[condition] || condition;
        }
        
        // 상태 번역 함수
        function translateStatus(status) {
            const statusMap = {
                '優勝決定': getTranslation('championship-decided'),
                'CS確定': getTranslation('playoff-secured'),
                '圏外確定': getTranslation('eliminated'),
                '可能性あり': getTranslation('still-possible')
            };
            return statusMap[status] || status;
        }
        
        // 팀명 번역 함수
        function translateTeamName(teamName, isShort = false) {
            if (!teamName) return teamName;
            
            // 팀명을 키로 변환하는 매핑 테이블
            const teamKeyMap = {
                // 일본어 팀명 -> 키
                '読売ジャイアンツ': 'giants',
                'ジャイアンツ': 'giants',
                '阪神タイガース': 'tigers', 
                'タイガース': 'tigers',
                '中日ドラゴンズ': 'dragons',
                'ドラゴンズ': 'dragons',
                '広島東洋カープ': 'carp',
                'カープ': 'carp',
                '東京ヤクルトスワローズ': 'swallows',
                'スワローズ': 'swallows',
                '横浜DeNAベイスターズ': 'baystars',
                'ベイスターズ': 'baystars',
                'ソフトバンクホークス': 'hawks',
                'ホークス': 'hawks',
                '東北楽天ゴールデンイーグルス': 'eagles',
                'イーグルス': 'eagles',
                '埼玉西武ライオンズ': 'lions',
                'ライオンズ': 'lions',
                '千葉ロッテマリーンズ': 'marines',
                'マリーンズ': 'marines',
                '北海道日本ハムファイターズ': 'fighters',
                'ファイターズ': 'fighters',
                'オリックスバファローズ': 'buffaloes',
                'バファローズ': 'buffaloes',
                
                // 영어 팀명 -> 키
                'Giants': 'giants',
                'Tigers': 'tigers',
                'Dragons': 'dragons',
                'Carp': 'carp', 
                'Swallows': 'swallows',
                'BayStars': 'baystars',
                'Hawks': 'hawks',
                'Eagles': 'eagles',
                'Lions': 'lions',
                'Marines': 'marines',
                'Fighters': 'fighters',
                'Buffaloes': 'buffaloes'
            };
            
            // 팀명에서 키 찾기
            let teamKey = teamKeyMap[teamName];
            if (!teamKey) {
                // 부분 매칭 시도
                for (const [name, key] of Object.entries(teamKeyMap)) {
                    if (teamName.includes(name) || name.includes(teamName)) {
                        teamKey = key;
                        break;
                    }
                }
            }
            
            if (teamKey) {
                const suffix = isShort ? '-short' : '';
                return getTranslation(teamKey + suffix);
            }
            
            return teamName; // 매칭되지 않으면 원래 이름 반환
        }
        
        // 언어 변경시 동적 콘텐츠도 재생성
        function refreshDynamicContent() {
            if (standingsData) {
                // 테이블 데이터 재생성
                updateAllTables();
            }
        }
        
        // 모든 테이블 업데이트 함수 (기존 함수들 호출)
        function updateAllTables() {
            // 매직넘버 테이블
            if (standingsData?.central_league?.standings) {
                updateMagicTable('central-magic-regular', standingsData.central_league.standings, true);
                updateMagicTable('central-magic-playoff', standingsData.central_league.standings, false);
            }
            if (standingsData?.pacific_league?.standings) {
                updateMagicTable('pacific-magic-regular', standingsData.pacific_league.standings, true);
                updateMagicTable('pacific-magic-playoff', standingsData.pacific_league.standings, false);
            }
            
            // 상세 순위표
            if (standingsData?.central_league?.standings) {
                updateDetailedTable('central-detailed', standingsData.central_league.standings);
            }
            if (standingsData?.pacific_league?.standings) {
                updateDetailedTable('pacific-detailed', standingsData.pacific_league.standings);
            }
        }
        
        // 기존 changeLanguage 함수 수정
        const originalChangeLanguage = changeLanguage;
        changeLanguage = function(lang) {
            originalChangeLanguage(lang);
            refreshDynamicContent();
        }
        
        // 페이지 로드시 언어 초기화
        document.addEventListener('DOMContentLoaded', function() {
            initLanguage();
        });


        // No JS footer init required; footer is static in HTML.
    </script>

    <!-- AdSense Ad - Mobile -->
    <ins class="adsbygoogle"
         style="display:block; margin: 20px auto;"
         data-ad-client="ca-pub-5508768187151867"
         data-ad-slot="7591944706"
         data-ad-format="auto"
         data-full-width-responsive="true"></ins>
    <script>
         (adsbygoogle = window.adsbygoogle || []).push({});
    </script>

    <!-- Site footer (static) -->
    <footer class="site-footer" role="contentinfo">
        <div class="footer-content">
            <span>© 2025 NPB Statistics</span>
            <span>|</span>
            <a href="https://npb-dashboard.com" target="_blank" rel="noopener noreferrer">npb-dashboard.com</a>
        </div>
    </footer>
</body>
</html>
