#!/usr/bin/env node

/**
 * KBO ÏãúÏ¶å Îç∞Ïù¥ÌÑ∞ ÏôÑÏ†Ñ ÏûêÎèôÌôî Ï≤òÎ¶¨ Ïä§ÌÅ¨Î¶ΩÌä∏
 * 2025-season-data-clean.txtÎ•º Í∏∞Î∞òÏúºÎ°ú Î™®Îì† ÏÑúÎπÑÏä§ ÏßÄÌëú Í≥ÑÏÇ∞
 */

const fs = require('fs');
const path = require('path');
const pathManager = require('../../config/paths');

class KBODataProcessor {
    constructor() {
        this.teams = ['ÌïúÌôî', 'LG', 'Î°ØÎç∞', 'SSG', 'KT', 'KIA', 'ÏÇºÏÑ±', 'NC', 'ÎëêÏÇ∞', 'ÌÇ§ÏõÄ'];
        this.allStarTeams = ['ÎÇòÎàî', 'ÎìúÎ¶º']; // Ïò¨Ïä§ÌÉÄ ÌåÄÎì§
        this.totalGamesPerSeason = 144;
        this.gamesPerOpponent = 16; // Í∞Å ÌåÄÎãπ 16Í≤ΩÍ∏∞Ïî©
        this.playoffSpots = 5;
        
        // KBO Ïã§Ï†ú ÏãúÏ¶å Í∏∞Ï§ÄÍ∞íÎì§
        this.typicalPlayoffWins = 80; // ÏùºÎ∞òÏ†ÅÏù∏ ÌîåÎ†àÏù¥Ïò§ÌîÑ ÏßÑÏ∂ú ÏäπÏàò
        this.typicalChampionshipWins = 87; // 144Í≤ΩÍ∏∞ Ï≤¥Ï†ú 1ÏúÑÌåÄ ÌèâÍ∑† ÏäπÏàò (2015-2024ÎÖÑ: 86.9Ïäπ)
        
        // Îç∞Ïù¥ÌÑ∞ Ï†ÄÏû•ÏÜå
        this.games = [];
        this.teamStats = {};
        this.headToHead = {};
        this.standings = [];
        this.magicNumbers = {};
        this.remainingGames = {};
    }

    // 1. Í≤ΩÍ∏∞ Îç∞Ïù¥ÌÑ∞ ÌååÏã±
    parseGameData() {
        console.log('üìñ Í≤ΩÍ∏∞ Îç∞Ïù¥ÌÑ∞ ÌååÏã± ÏãúÏûë...');
        
        try {
            // PathManagerÎ•º ÏÇ¨Ïö©ÌïòÏó¨ ÏãúÏ¶å Îç∞Ïù¥ÌÑ∞ ÌååÏùº Ï∞æÍ∏∞
            const dataFile = pathManager.findSeasonDataFile();
            
            if (!dataFile) {
                throw new Error('ÏãúÏ¶å Îç∞Ïù¥ÌÑ∞ ÌååÏùºÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.');
            }
            
            console.log(`üìÅ Îç∞Ïù¥ÌÑ∞ ÌååÏùº: ${dataFile}`);
            const data = fs.readFileSync(dataFile, 'utf8');
            const lines = data.trim().split('\n');
            
            let currentDate = '';
            let gameCount = 0;
            
            for (const line of lines) {
                const trimmedLine = line.trim();
                if (!trimmedLine) continue;
                
                // ÎÇ†Ïßú ÎùºÏù∏ Ï≤¥ÌÅ¨ (YYYY-MM-DD ÌòïÏãù)
                if (trimmedLine.match(/^\d{4}-\d{2}-\d{2}$/)) {
                    currentDate = trimmedLine;
                    continue;
                }
                
                // Í≤ΩÍ∏∞ Í≤∞Í≥º ÌååÏã± (ÌåÄ1 Ï†êÏàò:Ï†êÏàò ÌåÄ2(H) ÎòêÎäî ÌåÄ1 Ï†êÏàò:Ï†êÏàò ÌåÄ2)
                const gameMatch = trimmedLine.match(/^(.+?)\s+(\d+):(\d+)\s+(.+?)(\(H\))?$/);
                if (gameMatch) {
                    const [, team1, score1, score2, team2Raw, homeMarker] = gameMatch;
                    
                    // Ïò¨Ïä§ÌÉÄ Í≤ΩÍ∏∞ Ï†úÏô∏
                    if (this.allStarTeams.includes(team1.trim()) || this.allStarTeams.includes(team2Raw.trim())) {
                        console.log(`  ‚≠ê Ïò¨Ïä§ÌÉÄ Í≤ΩÍ∏∞ Ï†úÏô∏: ${team1} vs ${team2Raw}`);
                        continue;
                    }
                    
                    // ÌôàÌåÄ ÏãùÎ≥Ñ: (H) ÌëúÏãúÍ∞Ä ÏûàÏúºÎ©¥ Ìï¥Îãπ ÌåÄÏù¥ ÌôàÌåÄ, ÏóÜÏúºÎ©¥ Í∏∞Ï°¥ Í∑úÏπô Ï†ÅÏö©
                    let homeTeam, awayTeam, team2;
                    if (homeMarker === '(H)') {
                        // (H) ÌëúÏãúÍ∞Ä ÏûàÎäî Í≤ΩÏö∞ - Î™ÖÏãúÏ†Å ÌôàÌåÄ ÌëúÏãú
                        team2 = team2Raw;
                        homeTeam = team2;
                        awayTeam = team1;
                    } else {
                        // (H) ÌëúÏãúÍ∞Ä ÏóÜÎäî Í≤ΩÏö∞ - Í∏∞Ï°¥ Í∑úÏπô (Îí§Ïóê ÎÇòÏò® ÌåÄÏù¥ ÌôàÌåÄ)
                        team2 = team2Raw;
                        homeTeam = team2;
                        awayTeam = team1;
                    }
                    
                    // Í≤∞Í≥º ÌåêÏ†ï
                    let result;
                    if (parseInt(score1) > parseInt(score2)) {
                        result = { winner: team1, loser: team2, isDraw: false };
                    } else if (parseInt(score1) < parseInt(score2)) {
                        result = { winner: team2, loser: team1, isDraw: false };
                    } else {
                        result = { winner: null, loser: null, isDraw: true };
                    }
                    
                    this.games.push({
                        date: currentDate,
                        team1: team1,
                        team2: team2,
                        score1: parseInt(score1),
                        score2: parseInt(score2),
                        homeTeam: homeTeam,
                        awayTeam: awayTeam,
                        homeMarkerPresent: !!homeMarker, // Î†àÌçºÎü∞Ïä§Ïö©
                        ...result
                    });
                    
                    gameCount++;
                }
            }
            
            console.log(`‚úÖ ÌååÏã± ÏôÑÎ£å: ${gameCount}Í≤ΩÍ∏∞, ÏµúÏã† ÎÇ†Ïßú: ${currentDate}`);
            return { gameCount, lastDate: currentDate };
            
        } catch (error) {
            console.error('‚ùå ÌååÏã± Ïã§Ìå®:', error.message);
            throw error;
        }
    }

    // 2. ÌåÄÎ≥Ñ Í∏∞Î≥∏ ÌÜµÍ≥Ñ Í≥ÑÏÇ∞
    calculateTeamStats() {
        console.log('üìä ÌåÄÎ≥Ñ ÌÜµÍ≥Ñ Í≥ÑÏÇ∞ Ï§ë...');
        console.log(`  üéÆ Ï≤òÎ¶¨Ìï† Í≤ΩÍ∏∞ Ïàò: ${this.games.length}`);
        
        // Ï¥àÍ∏∞Ìôî
        this.teams.forEach(team => {
            this.teamStats[team] = {
                games: 0,
                wins: 0,
                losses: 0,
                draws: 0,
                homeWins: 0,
                homeLosses: 0,
                homeDraws: 0,
                awayWins: 0,
                awayLosses: 0,
                awayDraws: 0,
                recent10: [],
                currentStreak: { type: '', count: 0 }
            };
        });
        
        // Í≤ΩÍ∏∞Î≥Ñ ÌÜµÍ≥Ñ ÎàÑÏ†Å
        for (const game of this.games) {
            const { team1, team2, homeTeam, awayTeam, winner, loser, isDraw } = game;
            
            // ÌåÄ Ïù¥Î¶Ñ ÌôïÏù∏ (ÎîîÎ≤ÑÍπÖ)
            if (!this.teamStats[team1]) {
                console.error(`  ‚ùå Ïïå Ïàò ÏóÜÎäî ÌåÄ: '${team1}'`);
                console.error(`     Í≤ΩÍ∏∞ Ï†ïÎ≥¥:`, JSON.stringify(game));
                continue;
            }
            if (!this.teamStats[team2]) {
                console.error(`  ‚ùå Ïïå Ïàò ÏóÜÎäî ÌåÄ: '${team2}'`);
                console.error(`     Í≤ΩÍ∏∞ Ï†ïÎ≥¥:`, JSON.stringify(game));
                continue;
            }
            
            // Îëê ÌåÄ Î™®Îëê Í≤ΩÍ∏∞Ïàò Ï¶ùÍ∞Ä
            this.teamStats[team1].games++;
            this.teamStats[team2].games++;
            
            if (isDraw) {
                // Î¨¥ÏäπÎ∂Ä
                this.teamStats[team1].draws++;
                this.teamStats[team2].draws++;
                
                // Ìôà/ÏõêÏ†ï Î¨¥ÏäπÎ∂Ä
                this.teamStats[homeTeam].homeDraws++;
                this.teamStats[awayTeam].awayDraws++;
                
                // ÏµúÍ∑º 10Í≤ΩÍ∏∞ Í∏∞Î°ù
                this.teamStats[team1].recent10.push('Î¨¥');
                this.teamStats[team2].recent10.push('Î¨¥');
                
            } else {
                // ÏäπÎ∂Ä Í≤∞Ï†ï
                this.teamStats[winner].wins++;
                this.teamStats[loser].losses++;
                
                // Ìôà/ÏõêÏ†ï ÏäπÌå®
                if (winner === homeTeam) {
                    this.teamStats[winner].homeWins++;
                    this.teamStats[loser].awayLosses++;
                } else {
                    this.teamStats[winner].awayWins++;
                    this.teamStats[loser].homeLosses++;
                }
                
                // ÏµúÍ∑º 10Í≤ΩÍ∏∞ Í∏∞Î°ù
                this.teamStats[winner].recent10.push('Ïäπ');
                this.teamStats[loser].recent10.push('Ìå®');
            }
        }
        
        // ÌõÑÏ≤òÎ¶¨: ÏäπÎ•†, ÏµúÍ∑º 10Í≤ΩÍ∏∞, Ïó∞ÏÜç Í∏∞Î°ù Í≥ÑÏÇ∞
        this.teams.forEach(team => {
            const stats = this.teamStats[team];
            
            // ÏäπÎ•† Í≥ÑÏÇ∞
            stats.winRate = stats.wins / (stats.wins + stats.losses) || 0;
            
            // ÏµúÍ∑º 20Í≤ΩÍ∏∞ Ï†ïÎ¶¨ (Ïó∞ÏÜç Í∏∞Î°ù Í≥ÑÏÇ∞ÏùÑ ÏúÑÌï¥ Îçî ÎßéÏùÄ Í≤ΩÍ∏∞ Ï∂îÏ†Å)
            stats.recent10 = stats.recent10.slice(-20);
            const recent10Summary = this.formatRecent10(stats.recent10.slice(-10));
            stats.recent10Display = recent10Summary;
            
            // ÌòÑÏû¨ Ïó∞ÏÜç Í∏∞Î°ù Í≥ÑÏÇ∞
            stats.currentStreak = this.calculateStreak(stats.recent10);
            
            // Ìôà/ÏõêÏ†ï Í∏∞Î°ù Î¨∏ÏûêÏó¥
            stats.homeRecord = `${stats.homeWins}-${stats.homeLosses}-${stats.homeDraws}`;
            stats.awayRecord = `${stats.awayWins}-${stats.awayLosses}-${stats.awayDraws}`;
            
            console.log(`  üìà ${team}: ${stats.games}Í≤ΩÍ∏∞ ${stats.wins}Ïäπ${stats.losses}Ìå®${stats.draws}Î¨¥ (.${(stats.winRate * 1000).toFixed(0)})`);
        });
    }

    // 3. ÏÉÅÎåÄÏ†ÑÏ†Å Í≥ÑÏÇ∞
    calculateHeadToHead() {
        console.log('‚öîÔ∏è ÏÉÅÎåÄÏ†ÑÏ†Å Í≥ÑÏÇ∞ Ï§ë...');
        
        // Ï¥àÍ∏∞Ìôî
        this.teams.forEach(team1 => {
            this.headToHead[team1] = {};
            this.teams.forEach(team2 => {
                if (team1 !== team2) {
                    this.headToHead[team1][team2] = { 
                        wins: 0, losses: 0, draws: 0,
                        homeWins: 0, homeLosses: 0, homeDraws: 0,
                        awayWins: 0, awayLosses: 0, awayDraws: 0
                    };
                }
            });
        });
        
        // Í≤ΩÍ∏∞Î≥Ñ ÏÉÅÎåÄÏ†ÑÏ†Å Í≥ÑÏÇ∞
        for (const game of this.games) {
            const { team1, team2, homeTeam, awayTeam, winner, loser, isDraw } = game;
            
            if (isDraw) {
                // Ï†ÑÏ≤¥ Î¨¥ÏäπÎ∂Ä
                this.headToHead[team1][team2].draws++;
                this.headToHead[team2][team1].draws++;
                
                // Ìôà/ÏõêÏ†ï Î¨¥ÏäπÎ∂Ä
                this.headToHead[homeTeam][awayTeam].homeDraws++;
                this.headToHead[awayTeam][homeTeam].awayDraws++;
            } else {
                // Ï†ÑÏ≤¥ ÏäπÌå®
                this.headToHead[winner][loser].wins++;
                this.headToHead[loser][winner].losses++;
                
                // Ìôà/ÏõêÏ†ï ÏäπÌå®
                if (winner === homeTeam) {
                    // ÌôàÌåÄ ÏäπÎ¶¨
                    this.headToHead[homeTeam][awayTeam].homeWins++;
                    this.headToHead[awayTeam][homeTeam].awayLosses++;
                } else {
                    // ÏõêÏ†ïÌåÄ ÏäπÎ¶¨
                    this.headToHead[awayTeam][homeTeam].awayWins++;
                    this.headToHead[homeTeam][awayTeam].homeLosses++;
                }
            }
        }
        
        // ÏÉÅÎåÄÏ†ÑÏ†Å ÏöîÏïΩ Ï∂úÎ†•
        console.log('  ‚öîÔ∏è ÏÉÅÎåÄÏ†ÑÏ†Å Îß§Ìä∏Î¶≠Ïä§ ÏôÑÏÑ±');
        this.teams.forEach(team => {
            const totalGames = Object.values(this.headToHead[team])
                .reduce((sum, record) => sum + record.wins + record.losses + record.draws, 0);
            console.log(`    ${team}: Ï¥ù ${totalGames}Í≤ΩÍ∏∞`);
        });
    }

    // 4. ÏûîÏó¨Í≤ΩÍ∏∞ Í≥ÑÏÇ∞
    calculateRemainingGames() {
        console.log('üìÖ ÏûîÏó¨Í≤ΩÍ∏∞ Í≥ÑÏÇ∞ Ï§ë...');
        
        this.teams.forEach(team1 => {
            this.remainingGames[team1] = {};
            let totalRemaining = 0;
            
            this.teams.forEach(team2 => {
                if (team1 !== team2) {
                    const played = this.headToHead[team1][team2].wins + 
                                  this.headToHead[team1][team2].losses + 
                                  this.headToHead[team1][team2].draws;
                    
                    const remaining = this.gamesPerOpponent - played;
                    this.remainingGames[team1][team2] = Math.max(0, remaining);
                    totalRemaining += this.remainingGames[team1][team2];
                }
            });
            
            this.remainingGames[team1].total = totalRemaining;
            console.log(`  üìÖ ${team1}: ${totalRemaining}Í≤ΩÍ∏∞ ÎÇ®Ïùå`);
        });
    }

    // 5. ÏàúÏúÑ Í≥ÑÏÇ∞
    calculateStandings() {
        console.log('üèÜ ÏàúÏúÑ Í≥ÑÏÇ∞ Ï§ë...');
        
        this.standings = this.teams.map(team => {
            const stats = this.teamStats[team];
            return {
                team: team,
                games: stats.games,
                wins: stats.wins,
                losses: stats.losses,
                draws: stats.draws,
                winRate: stats.winRate,
                homeRecord: stats.homeRecord,
                awayRecord: stats.awayRecord,
                homeWins: stats.homeWins,
                homeLosses: stats.homeLosses,
                homeDraws: stats.homeDraws,
                awayWins: stats.awayWins,
                awayLosses: stats.awayLosses,
                awayDraws: stats.awayDraws,
                recent10: stats.recent10Display,
                streak: this.formatStreak(stats.currentStreak),
                remainingGames: this.remainingGames[team].total
            };
        });
        
        // ÏàúÏúÑ Ï†ïÎ†¨ (ÏäπÎ•† Í∏∞Ï§Ä)
        this.standings.sort((a, b) => {
            if (b.winRate !== a.winRate) return b.winRate - a.winRate;
            if (b.wins !== a.wins) return b.wins - a.wins;
            return a.losses - b.losses;
        });
        
        // Í≥µÎèô ÏàúÏúÑ Í≥ÑÏÇ∞ - Ï¢ÖÌï© ÏàúÏúÑÏôÄ ÎèôÏùºÌïú Î°úÏßÅ Ï†ÅÏö©
        let currentRank = 1;
        let previousWinRate = null;
        
        this.standings.forEach((team, index) => {
            const displayedWinRate = parseFloat(team.winRate.toFixed(3));
            if (previousWinRate !== null && displayedWinRate !== previousWinRate) {
                currentRank = index + 1;
            }
            team.rank = currentRank;
            previousWinRate = displayedWinRate;
            
            // Í≤åÏûÑÏ∞® Í≥ÑÏÇ∞
            if (index === 0) {
                team.gamesBehind = 0;
            } else {
                const firstPlace = this.standings[0];
                team.gamesBehind = (firstPlace.wins - team.wins + team.losses - firstPlace.losses) / 2;
            }
        });
        
        console.log('  üèÜ ÏàúÏúÑÌëú ÏôÑÏÑ±:');
        this.standings.forEach(team => {
            console.log(`    ${team.rank}ÏúÑ ${team.team} (${team.wins}-${team.losses}-${team.draws}, .${(team.winRate * 1000).toFixed(0)})`);
        });
    }

    // 6. Îß§ÏßÅÎÑòÎ≤Ñ Í≥ÑÏÇ∞
    calculateMagicNumbers() {
        console.log('üîÆ Îß§ÏßÅÎÑòÎ≤Ñ Í≥ÑÏÇ∞ Ï§ë...');
        
        this.magicNumbers = {};
        
        this.standings.forEach((team, index) => {
            const remainingGames = team.remainingGames;
            const maxPossibleWins = team.wins + remainingGames;
            
            // ÌîåÎ†àÏù¥Ïò§ÌîÑ ÏßÑÏ∂ú Îß§ÏßÅÎÑòÎ≤Ñ
            let playoffMagic = this.calculatePlayoffMagic(team, index);
            
            // Ïö∞Ïäπ Îß§ÏßÅÎÑòÎ≤Ñ  
            let championshipMagic = this.calculateChampionshipMagic(team, index);
            
            // ÌÉàÎùΩ Îß§ÏßÅÎÑòÎ≤Ñ
            let eliminationMagic = this.calculateEliminationMagic(team, index);
            
            // Ìôà Ïñ¥ÎìúÎ∞¥Ìã∞ÏßÄ Îß§ÏßÅÎÑòÎ≤Ñ (2ÏúÑ ÌôïÏ†ï)
            let homeAdvantage = this.calculateHomeAdvantageMagic(team, index);
            
            this.magicNumbers[team.team] = {
                playoff: playoffMagic,
                championship: championshipMagic,
                elimination: eliminationMagic,
                homeAdvantage: homeAdvantage,
                remainingGames: remainingGames,
                maxPossibleWins: maxPossibleWins,
                currentRank: team.rank
            };
            
            console.log(`  üéØ ${team.team} (${team.rank}ÏúÑ): PO ${playoffMagic}, Ïö∞Ïäπ ${championshipMagic}`);
        });
    }

    // Îß§ÏßÅÎÑòÎ≤Ñ Í≥ÑÏÇ∞ Ìó¨Ìçº Ìï®ÏàòÎì§
    calculatePlayoffMagic(team, index) {
        /**
         * ÌîåÎ†àÏù¥Ïò§ÌîÑ Îß§ÏßÅÎÑòÎ≤Ñ Í≥ÑÏÇ∞ Í∏∞Ï§Ä:
         * 1. ÏÇ∞Ïà†Ï†Å Îß§ÏßÅÎÑòÎ≤Ñ: ÌòÑÏû¨ 5ÏúÑÌåÄÏùò ÏµúÎåÄ Í∞ÄÎä• ÏäπÏàò + 1 (Ïã§ÏãúÍ∞Ñ Í≥ÑÏÇ∞)
         * 2. Ïó≠ÎåÄ Í∏∞Ï§Ä Îß§ÏßÅÎÑòÎ≤Ñ: 72Ïäπ Í∏∞Ï§Ä (Ïó≠ÎåÄ 5ÏúÑ ÌèâÍ∑† ÏäπÏàò)
         * 
         * ÌòÑÏû¨ Ï†ÅÏö©: Ïó≠ÎåÄ Í∏∞Ï§Ä Îß§ÏßÅÎÑòÎ≤Ñ (72Ïäπ Í∏∞Ï§Ä)
         * - ÏïàÏ†ïÏ†ÅÏù¥Í≥† ÏòàÏ∏° Í∞ÄÎä•Ìïú Í∏∞Ï§Ä
         * - ÏãúÏ¶å ÌõÑÎ∞òÍπåÏßÄ ÏùºÍ¥ÄÎêú Î™©Ìëú Ï†úÏãú
         */
        const PLAYOFF_THRESHOLD = 72; // Ïó≠ÎåÄ 5ÏúÑ ÌèâÍ∑† ÏäπÏàò Í∏∞Ï§Ä
        
        // ÌòÑÏû¨ ÌåÄÏù¥ 72ÏäπÏùÑ Îã¨ÏÑ±ÌïòÍ∏∞ ÏúÑÌï¥ ÌïÑÏöîÌïú ÏäπÏàò
        const neededWins = Math.max(0, PLAYOFF_THRESHOLD - team.wins);
        
        // ÎÇ®ÏùÄ Í≤ΩÍ∏∞Î°ú Îã¨ÏÑ± Í∞ÄÎä•ÌïúÏßÄ ÌôïÏù∏
        if (neededWins > team.remainingGames) {
            return 999; // ÏàòÌïôÏ†ÅÏúºÎ°ú Î∂àÍ∞ÄÎä•
        }
        
        // Ïù¥ÎØ∏ 72Ïäπ Ïù¥ÏÉÅÏù¥Î©¥ ÌôïÏ†ï
        if (team.wins >= PLAYOFF_THRESHOLD) {
            return 0;
        }
        
        return neededWins;
    }

    calculateChampionshipMagic(team, index) {
        if (index === 0) {
            // ÌòÑÏû¨ 1ÏúÑ - ÏäπÎ•† Í∏∞Î∞ò Ïö∞Ïäπ ÌôïÏ†ï Îß§ÏßÅÎÑòÎ≤Ñ
            const secondPlace = this.standings[1];
            if (!secondPlace) return 0; // 2ÏúÑÍ∞Ä ÏóÜÏúºÎ©¥ Ïù¥ÎØ∏ ÌôïÏ†ï
            
            // 2ÏúÑ ÌåÄÏùò ÏµúÎåÄ Í∞ÄÎä• ÏäπÎ•† Í≥ÑÏÇ∞
            const secondMaxWins = secondPlace.wins + secondPlace.remainingGames;
            const secondMaxLosses = secondPlace.losses; // Î™®Îì† Í≤ΩÍ∏∞ ÏäπÎ¶¨ Í∞ÄÏ†ï
            const secondMaxWinRate = secondMaxWins / (secondMaxWins + secondMaxLosses);
            
            // 1ÏúÑ ÌåÄÏù¥ 2ÏúÑ ÏµúÎåÄ ÏäπÎ•†ÏùÑ ÎÑòÍ∏∞ ÏúÑÌïú Îß§ÏßÅÎÑòÎ≤Ñ Í≥ÑÏÇ∞
            for (let additionalWins = 0; additionalWins <= team.remainingGames; additionalWins++) {
                const finalWins = team.wins + additionalWins;
                const finalLosses = team.losses + (team.remainingGames - additionalWins);
                const finalWinRate = finalWins / (finalWins + finalLosses);
                
                if (finalWinRate > secondMaxWinRate) {
                    return additionalWins;
                }
            }
            
            // Î™®Îì† Í≤ΩÍ∏∞Î•º Ïù¥Í≤®ÎèÑ 2ÏúÑÎ•º ÎÑòÏùÑ Ïàò ÏóÜÎäî Í≤ΩÏö∞ - ÏûîÏó¨Í≤ΩÍ∏∞Ïàò ÌëúÏãú
            return team.remainingGames;
            
        } else {
            // 1ÏúÑÍ∞Ä ÏïÑÎãò - ÏäπÎ•† Í∏∞Î∞ò 1ÏúÑ Ï∂îÏõî Îß§ÏßÅÎÑòÎ≤Ñ
            const firstPlace = this.standings[0];
            
            // 1ÏúÑ ÌåÄÏùò ÏµúÎåÄ Í∞ÄÎä• ÏäπÎ•† Í≥ÑÏÇ∞
            const firstMaxWins = firstPlace.wins + firstPlace.remainingGames;
            const firstMaxLosses = firstPlace.losses; // Î™®Îì† Í≤ΩÍ∏∞ ÏäπÎ¶¨ Í∞ÄÏ†ï
            const firstMaxWinRate = firstMaxWins / (firstMaxWins + firstMaxLosses);
            
            // ÌòÑÏû¨ ÌåÄÏù¥ 1ÏúÑ ÏµúÎåÄ ÏäπÎ•†ÏùÑ ÎÑòÍ∏∞ ÏúÑÌïú Îß§ÏßÅÎÑòÎ≤Ñ Í≥ÑÏÇ∞
            for (let additionalWins = 0; additionalWins <= team.remainingGames; additionalWins++) {
                const finalWins = team.wins + additionalWins;
                const finalLosses = team.losses + (team.remainingGames - additionalWins);
                const finalWinRate = finalWins / (finalWins + finalLosses);
                
                if (finalWinRate > firstMaxWinRate) {
                    return additionalWins;
                }
            }
            
            // Î™®Îì† Í≤ΩÍ∏∞Î•º Ïù¥Í≤®ÎèÑ 1ÏúÑÎ•º ÎÑòÏùÑ Ïàò ÏóÜÎäî Í≤ΩÏö∞ - ÏûîÏó¨Í≤ΩÍ∏∞Ïàò ÌëúÏãú
            return team.remainingGames;
        }
    }

    calculateEliminationMagic(team, index) {
        /**
         * Ìä∏ÎûòÏßÅÎÑòÎ≤Ñ Í≥ÑÏÇ∞ Í∏∞Ï§Ä:
         * 1. ÏÇ∞Ïà†Ï†Å Ìä∏ÎûòÏßÅÎÑòÎ≤Ñ: ÌòÑÏû¨ 5ÏúÑÌåÄÏùÑ ÎÑòÏñ¥ÏÑ§ Ïàò ÏóÜÍ≤å ÎêòÎäî Ìå®Î∞∞ Ïàò (Ïã§ÏãúÍ∞Ñ Í≥ÑÏÇ∞)
         * 2. Ïó≠ÎåÄ Í∏∞Ï§Ä Ìä∏ÎûòÏßÅÎÑòÎ≤Ñ: 72Ïäπ Îã¨ÏÑ± Î∂àÍ∞ÄÎä•Ìï¥ÏßÄÎäî Ìå®Î∞∞ Ïàò
         * 
         * ÌòÑÏû¨ Ï†ÅÏö©: Ïó≠ÎåÄ Í∏∞Ï§Ä Ìä∏ÎûòÏßÅÎÑòÎ≤Ñ (72Ïäπ Í∏∞Ï§Ä)
         * - ÌîåÎ†àÏù¥Ïò§ÌîÑ Îß§ÏßÅÎÑòÎ≤ÑÏôÄ ÏùºÍ¥ÄÏÑ± Ïú†ÏßÄ
         * - ÏïàÏ†ïÏ†ÅÏù∏ ÌÉàÎùΩ Í∏∞Ï§Ä Ï†úÏãú
         */
        const PLAYOFF_THRESHOLD = 72; // Ïó≠ÎåÄ 5ÏúÑ ÌèâÍ∑† ÏäπÏàò Í∏∞Ï§Ä
        const currentWins = team.wins;
        const currentLosses = team.losses;
        const remainingGames = team.remainingGames;
        const maxPossibleWins = currentWins + remainingGames;
        
        // Ïù¥ÎØ∏ 72Ïäπ Îã¨ÏÑ±Ïù¥ ÏàòÌïôÏ†ÅÏúºÎ°ú Î∂àÍ∞ÄÎä•ÌïòÎ©¥ ÌÉàÎùΩ
        if (maxPossibleWins < PLAYOFF_THRESHOLD) {
            return 0; // 0Ïù¥Î©¥ "ÌÉàÎùΩ"ÏúºÎ°ú ÌëúÏãú
        }
        
        // 72Ïäπ Îã¨ÏÑ±ÏùÑ ÏúÑÌï¥ ÌïÑÏöîÌïú ÏµúÏÜå ÏäπÏàò
        const neededWins = PLAYOFF_THRESHOLD - currentWins;
        
        // ÎÇ®ÏùÄ Í≤ΩÍ∏∞ÏóêÏÑú Î™®Îëê Ï†∏ÎèÑ 72Ïäπ Îã¨ÏÑ± Í∞ÄÎä•Ìïú Í≤ΩÏö∞
        if (neededWins <= 0) {
            return 999; // Ïù¥ÎØ∏ 72Ïäπ Îã¨ÏÑ±ÌñàÍ±∞ÎÇò ÌôïÏ†ïÏ†ÅÏúºÎ°ú Îã¨ÏÑ± Í∞ÄÎä•
        }
        
        // 72Ïäπ Îã¨ÏÑ± Î∂àÍ∞ÄÎä•Ìï¥ÏßÄÎäî Ìå®Î∞∞ Ïàò Í≥ÑÏÇ∞
        // Ï¶â, ÎÇ®ÏùÄ Í≤ΩÍ∏∞ ÏàòÍ∞Ä ÌïÑÏöîÌïú ÏäπÏàòÎ≥¥Îã§ Ï†ÅÏñ¥ÏßÄÎäî ÏãúÏ†ê
        const maxAllowableLosses = remainingGames - neededWins;
        
        if (maxAllowableLosses <= 0) {
            return 0; // Ïù¥ÎØ∏ ÌÉàÎùΩ
        }
        
        // ÌòÑÏû¨Î∂ÄÌÑ∞ Î™á Ìå® Îçî ÌïòÎ©¥ ÌÉàÎùΩÏù∏ÏßÄ Í≥ÑÏÇ∞
        return maxAllowableLosses;
    }

    calculateHomeAdvantageMagic(team, index) {
        // Ìôà Ïñ¥ÎìúÎ∞¥Ìã∞ÏßÄ Îß§ÏßÅÎÑòÎ≤Ñ: 2ÏúÑ Ïù¥ÎÇ¥ ÌôïÏ†ïÏùÑ ÏúÑÌïú Îß§ÏßÅÎÑòÎ≤Ñ
        if (index <= 1) {
            // ÌòÑÏû¨ 1-2ÏúÑ - Ìôà Ïñ¥ÎìúÎ∞¥Ìã∞ÏßÄ ÌôïÏ†ïÏùÑ ÏúÑÌïú Îß§ÏßÅÎÑòÎ≤Ñ
            const thirdPlace = this.standings[2];
            if (!thirdPlace) return 0; // 3ÏúÑÍ∞Ä ÏóÜÏúºÎ©¥ Ïù¥ÎØ∏ ÌôïÏ†ï
            
            // 3ÏúÑ ÌåÄÏùò ÏµúÎåÄ Í∞ÄÎä• ÏäπÏàòÎ≥¥Îã§ 1Ïäπ Îçî ÌïÑÏöî
            const thirdMaxWins = thirdPlace.wins + thirdPlace.remainingGames;
            const neededWins = Math.max(0, thirdMaxWins - team.wins + 1);
            
            // ÎÇ®ÏùÄ Í≤ΩÍ∏∞Î°ú Îã¨ÏÑ± Í∞ÄÎä•ÌïúÏßÄ ÌôïÏù∏
            return neededWins > team.remainingGames ? 999 : neededWins;
        } else {
            // 3ÏúÑ Ïù¥Ìïò - 2ÏúÑ ÏßÑÏûÖÏùÑ ÏúÑÌïú Îß§ÏßÅÎÑòÎ≤Ñ
            const secondPlace = this.standings[1];
            const maxPossibleWins = team.wins + team.remainingGames;
            
            // ÏàòÌïôÏ†ÅÏúºÎ°ú Î∂àÍ∞ÄÎä•Ìïú Í≤ΩÏö∞
            if (maxPossibleWins < secondPlace.wins) {
                return 999; // Ïù¥ÎØ∏ ÏàòÌïôÏ†Å Î∂àÍ∞ÄÎä•
            }
            
            // 2ÏúÑ ÌåÄÏùÑ ÎÑòÏñ¥ÏÑúÍ∏∞ ÏúÑÌï¥ ÌïÑÏöîÌïú ÏäπÏàò
            const neededWins = Math.max(0, secondPlace.wins - team.wins + 1);
            return neededWins > team.remainingGames ? 999 : neededWins;
        }
    }

    // 7. ÌÜµÌï© ÏÑúÎπÑÏä§ Îç∞Ïù¥ÌÑ∞ ÏÉùÏÑ±
    generateServiceData() {
        console.log('üì¶ ÌÜµÌï© ÏÑúÎπÑÏä§ Îç∞Ïù¥ÌÑ∞ ÏÉùÏÑ± Ï§ë...');
        
        const serviceData = {
            lastUpdated: new Date().toISOString(),
            updateDate: new Date().toLocaleDateString('ko-KR'),
            note: '2025-season-data-clean.txt Í∏∞Î∞ò ÏôÑÏ†Ñ ÏûêÎèôÌôî Ï≤òÎ¶¨',
            source: 'CLEAN_TXT_AUTOMATION',
            dataDate: this.games.length > 0 ? this.games[this.games.length - 1].date : null,
            totalGames: this.games.length,
            
            // ÏàúÏúÑÌëú
            standings: this.standings,
            
            // Îß§ÏßÅÎÑòÎ≤Ñ
            magicNumbers: this.magicNumbers,
            
            // ÏÉÅÎåÄÏ†ÑÏ†Å
            headToHead: this.headToHead,
            
            // ÏûîÏó¨Í≤ΩÍ∏∞
            remainingGames: this.remainingGames,
            
            // 1ÏúÑ ÌÉàÌôò Í∞ÄÎä•ÏÑ± Îç∞Ïù¥ÌÑ∞
            chaseData: this.generateChaseData(),
            
            // ÌîåÎ†àÏù¥Ïò§ÌîÑ ÏßÑÏ∂ú Îç∞Ïù¥ÌÑ∞
            playoffData: this.generatePlayoffData()
        };
        
        return serviceData;
    }

    // 1ÏúÑ ÌÉàÌôò Í∞ÄÎä•ÏÑ± Îç∞Ïù¥ÌÑ∞ ÏÉùÏÑ±
    generateChaseData() {
        const firstPlace = this.standings[0];
        
        return this.standings.slice(1).map(team => {
            const maxPossibleWins = team.wins + team.remainingGames;
            const canChase = maxPossibleWins > firstPlace.wins;
            const firstTeamNeedToLose = Math.max(0, maxPossibleWins - firstPlace.wins);
            const requiredWinRate = team.remainingGames > 0 ? 
                Math.min(1, (this.typicalChampionshipWins - team.wins) / team.remainingGames) : 0;
            
            return {
                team: team.team,
                rank: team.rank,
                wins: team.wins,
                gamesBehind: team.gamesBehind,
                remainingGames: team.remainingGames,
                maxPossibleWins: maxPossibleWins,
                firstTeamNeedToLose: firstTeamNeedToLose,
                canChase: canChase,
                requiredWinRate: requiredWinRate,
                canReachChampionshipWins: maxPossibleWins >= this.typicalChampionshipWins
            };
        });
    }

    // ÌîåÎ†àÏù¥Ïò§ÌîÑ ÏßÑÏ∂ú Îç∞Ïù¥ÌÑ∞ ÏÉùÏÑ±
    generatePlayoffData() {
        return this.standings.map(team => {
            const magic = this.magicNumbers[team.team];
            const PLAYOFF_THRESHOLD = 72;
            
            // ÏûîÏó¨Í≤ΩÍ∏∞ ÌïÑÏöî ÏäπÎ•†: 72Ïäπ Îã¨ÏÑ±ÏùÑ ÏúÑÌïú ÏäπÎ•†
            const requiredWinRate = team.remainingGames > 0 ? 
                Math.min(1, Math.max(0, PLAYOFF_THRESHOLD - team.wins) / team.remainingGames) : 0;
            
            // ÏßÑÏ∂ú ÏÉÅÌô© ÌåêÏ†ï (Í∑∏ÎùºÎç∞Ïù¥ÏÖò Í∏∞Î∞ò)
            let status;
            if (team.wins >= PLAYOFF_THRESHOLD) {
                status = 'ÌôïÏ†ï'; // Ïù¥ÎØ∏ 72Ïäπ Îã¨ÏÑ±
            } else if (team.wins + team.remainingGames < PLAYOFF_THRESHOLD) {
                status = 'Î∂àÍ∞ÄÎä•'; // Ï†ÑÏäπÌï¥ÎèÑ 72Ïäπ Î∂àÍ∞Ä
            } else {
                // ÌïÑÏöî ÏäπÎ•†Ïóê Îî∞Î•∏ Í∑∏ÎùºÎç∞Ïù¥ÏÖò Íµ¨Î∂Ñ
                if (requiredWinRate <= 0.3) {
                    status = 'Îß§Ïö∞ Ïú†Î†•';
                } else if (requiredWinRate <= 0.5) {
                    status = 'Ïú†Î†•';
                } else if (requiredWinRate <= 0.7) {
                    status = 'Í≤ΩÌï©';
                } else if (requiredWinRate <= 0.85) {
                    status = 'Ïñ¥Î†§ÏõÄ';
                } else {
                    status = 'Îß§Ïö∞ Ïñ¥Î†§ÏõÄ';
                }
            }
            
            return {
                team: team.team,
                rank: team.rank,
                wins: team.wins,
                remainingGames: team.remainingGames,
                maxPossibleWins: magic.maxPossibleWins,
                playoffMagic: magic.playoff === 999 ? 'Î∂àÍ∞ÄÎä•' : magic.playoff,
                eliminationMagic: magic.elimination === 999 ? '-' : magic.elimination,
                requiredWinRate: requiredWinRate,
                status: status
            };
        });
    }

    // 8. ÌååÏùº Ï†ÄÏû•
    async saveAllData(serviceData) {
        console.log('üíæ Îç∞Ïù¥ÌÑ∞ ÌååÏùº Ï†ÄÏû• Ï§ë...');
        
        try {
            // 1. PathManagerÎ•º ÏÇ¨Ïö©Ìïú ÏïàÏ†ÑÌïú Í≤ΩÎ°úÎ°ú ÌÜµÌï© Îç∞Ïù¥ÌÑ∞ Ï†ÄÏû•
            pathManager.ensureDir(pathManager.dataDir);
            const serviceDataPath = pathManager.getDataFile('service-data.json');
            fs.writeFileSync(serviceDataPath, JSON.stringify(serviceData, null, 2));
            console.log(`  ‚úÖ ${serviceDataPath} Ï†ÄÏû• ÏôÑÎ£å`);
            
            // 2. magic-number Ìè¥ÎçîÏóê ÏõπÏÑúÎπÑÏä§Ïö© ÌååÏùºÎì§ ÏÉùÏÑ±
            const rankingsData = {
                lastUpdated: serviceData.lastUpdated,
                updateDate: serviceData.updateDate,
                note: serviceData.note,
                rankings: serviceData.standings.map(team => ({
                    rank: team.rank,
                    team: team.team,
                    games: team.games,
                    wins: team.wins,
                    losses: team.losses,
                    draws: team.draws,
                    winRate: parseFloat(team.winRate.toFixed(3)),
                    gamesBehind: team.gamesBehind,
                    recent10: team.recent10,
                    streak: team.streak,
                    homeRecord: team.homeRecord,
                    awayRecord: team.awayRecord
                })),
                magicNumbers: serviceData.magicNumbers,
                lastMagicUpdate: serviceData.lastUpdated,
                totalTeams: 10,
                source: serviceData.source,
                dataDate: serviceData.dataDate
            };
            
            // 3. PathManagerÎ•º ÏÇ¨Ïö©Ìïú ÏïàÏ†ÑÌïú Í≤ΩÎ°úÎ°ú ÏõπÏÑúÎπÑÏä§ ÌååÏùºÎì§ ÏÉùÏÑ±
            const rankingsPath = pathManager.getDataFile('kbo-rankings.json');
            fs.writeFileSync(rankingsPath, JSON.stringify(rankingsData, null, 2));
            
            // ÏÉÅÎåÄÏ†ÑÏ†Å Îç∞Ïù¥ÌÑ∞ÎèÑ ÏóÖÎç∞Ïù¥Ìä∏
            const recordsData = {
                lastUpdated: serviceData.lastUpdated,
                updateDate: serviceData.updateDate,
                note: serviceData.note,
                totalData: serviceData.headToHead,
                source: serviceData.source,
                dataDate: serviceData.dataDate
            };
            
            const recordsPath = pathManager.getDataFile('kbo-records.json');
            fs.writeFileSync(recordsPath, JSON.stringify(recordsData, null, 2));
            
            // service-data.jsonÏùÄ Ïù¥ÎØ∏ ÏúÑÏóêÏÑú Ï†ÄÏû•Îê®
            
            console.log(`  ‚úÖ ${rankingsPath} Ï†ÄÏû• ÏôÑÎ£å`);
            console.log(`  ‚úÖ ${recordsPath} Ï†ÄÏû• ÏôÑÎ£å`);
            
        } catch (error) {
            console.error('‚ùå ÌååÏùº Ï†ÄÏû• Ïã§Ìå®:', error.message);
            throw error;
        }
    }

    // Ïú†Ìã∏Î¶¨Ìã∞ Ìï®ÏàòÎì§
    formatRecent10(games) {
        const wins = games.filter(g => g === 'Ïäπ').length;
        const losses = games.filter(g => g === 'Ìå®').length;
        const draws = games.filter(g => g === 'Î¨¥').length;
        
        return `${wins}Ïäπ${draws}Î¨¥${losses}Ìå®`;
    }

    calculateStreak(recent) {
        if (recent.length === 0) return { type: '', count: 0 };
        
        // Í∞ÄÏû• ÏµúÍ∑ºÎ∂ÄÌÑ∞ Í±∞Íæ∏Î°ú ÏàúÌöåÌïòÎ©∞ Ïäπ ÎòêÎäî Ìå® Ïó∞ÏÜç Ï∞æÍ∏∞
        let streakType = '';
        let count = 0;
        
        for (let i = recent.length - 1; i >= 0; i--) {
            const result = recent[i];
            
            // Î¨¥ÏäπÎ∂ÄÎäî Ïó∞ÏÜçÏóê ÏòÅÌñ•ÏùÑ Ï£ºÏßÄ ÏïäÏùå (Í±¥ÎìúÎ¶¨ÏßÄ ÏïäÍ≥† Ìå®Ïä§)
            if (result === 'Î¨¥') {
                continue;
            }
            
            // Ï≤´ Î≤àÏß∏ Ïäπ/Ìå® Í≤∞Í≥ºÎ•º Ï∞æÏùÄ Í≤ΩÏö∞
            if (streakType === '') {
                streakType = result;
                count = 1;
            }
            // Í∞ôÏùÄ Í≤∞Í≥ºÍ∞Ä Ïó∞ÏÜçÎêòÎäî Í≤ΩÏö∞
            else if (result === streakType) {
                count++;
            }
            // Îã§Î•∏ Í≤∞Í≥ºÍ∞Ä ÎÇòÏò§Î©¥ Ïó∞ÏÜç Ï§ëÎã®
            else {
                break;
            }
        }
        
        return { type: streakType, count: count };
    }

    formatStreak(streak) {
        if (streak.count === 0) return '-';
        return `${streak.count}${streak.type}`;
    }

    // Î©îÏù∏ Ïã§Ìñâ Ìï®Ïàò
    async run() {
        try {
            console.log('üöÄ KBO Îç∞Ïù¥ÌÑ∞ ÏôÑÏ†Ñ ÏûêÎèôÌôî Ï≤òÎ¶¨ ÏãúÏûë...\n');
            
            // 1Îã®Í≥Ñ: Îç∞Ïù¥ÌÑ∞ ÌååÏã±
            const parseResult = this.parseGameData();
            
            // 2Îã®Í≥Ñ: ÌÜµÍ≥Ñ Í≥ÑÏÇ∞
            this.calculateTeamStats();
            
            // 3Îã®Í≥Ñ: ÏÉÅÎåÄÏ†ÑÏ†Å Í≥ÑÏÇ∞
            this.calculateHeadToHead();
            
            // 4Îã®Í≥Ñ: ÏûîÏó¨Í≤ΩÍ∏∞ Í≥ÑÏÇ∞
            this.calculateRemainingGames();
            
            // 5Îã®Í≥Ñ: ÏàúÏúÑ Í≥ÑÏÇ∞
            this.calculateStandings();
            
            // 6Îã®Í≥Ñ: Îß§ÏßÅÎÑòÎ≤Ñ Í≥ÑÏÇ∞
            this.calculateMagicNumbers();
            
            // 7Îã®Í≥Ñ: ÏÑúÎπÑÏä§ Îç∞Ïù¥ÌÑ∞ ÏÉùÏÑ±
            const serviceData = this.generateServiceData();
            
            // 8Îã®Í≥Ñ: ÌååÏùº Ï†ÄÏû•
            await this.saveAllData(serviceData);
            
            console.log('\nüéâ KBO Îç∞Ïù¥ÌÑ∞ ÏôÑÏ†Ñ ÏûêÎèôÌôî Ï≤òÎ¶¨ ÏôÑÎ£å!');
            console.log(`üìä Ï¥ù ${parseResult.gameCount}Í≤ΩÍ∏∞ Ï≤òÎ¶¨`);
            console.log(`üìÖ ÏµúÏã† Îç∞Ïù¥ÌÑ∞: ${parseResult.lastDate}`);
            console.log('üìÅ ÏÉùÏÑ±Îêú ÌååÏùº:');
            console.log(`   - ${pathManager.getDataFile('service-data.json')} (ÌÜµÌï© ÏõπÏÑúÎπÑÏä§ Îç∞Ïù¥ÌÑ∞)`);
            console.log(`   - ${pathManager.getDataFile('kbo-rankings.json')} (ÏõπÏÑúÎπÑÏä§Ïö© ÏàúÏúÑ)`);
            console.log(`   - ${pathManager.getDataFile('kbo-records.json')} (ÏõπÏÑúÎπÑÏä§Ïö© ÏÉÅÎåÄÏ†ÑÏ†Å)`);
            
        } catch (error) {
            console.error('\n‚ùå Ï≤òÎ¶¨ Ï§ë Ïò§Î•ò Î∞úÏÉù:', error.message);
            process.exit(1);
        }
    }
}

// Ïã§Ìñâ
if (require.main === module) {
    const processor = new KBODataProcessor();
    processor.run();
}

module.exports = KBODataProcessor;