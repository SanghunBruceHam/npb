/**
 * NPB API ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏
 * Ïã§Ï†ú NPB Îç∞Ïù¥ÌÑ∞Î•º Í∞ÄÏ†∏Ïò§Îäî Ïó≠Ìï†
 */
class NPBApiClient {
    constructor() {
        this.baseUrl = '/data'; // Î°úÏª¨ Îç∞Ïù¥ÌÑ∞ Ìè¥Îçî
        this.retryCount = 3;
        this.timeout = 10000; // 10Ï¥à
    }
    
    /**
     * HTTP ÏöîÏ≤≠ Ìó¨Ìçº Î©îÏÑúÎìú
     */
    async request(url, options = {}) {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), this.timeout);
        
        try {
            const response = await fetch(url, {
                ...options,
                signal: controller.signal
            });
            
            clearTimeout(timeoutId);
            
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            
            const data = await response.json();
            return data;
        } catch (error) {
            clearTimeout(timeoutId);
            
            if (error.name === 'AbortError') {
                throw new Error('ÏöîÏ≤≠ ÏãúÍ∞Ñ Ï¥àÍ≥º');
            }
            throw error;
        }
    }
    
    /**
     * Ïû¨ÏãúÎèÑ Î°úÏßÅÏù¥ Ìè¨Ìï®Îêú ÏöîÏ≤≠
     */
    async requestWithRetry(url, options = {}, retries = this.retryCount) {
        try {
            return await this.request(url, options);
        } catch (error) {
            if (retries > 0) {
                console.warn(`‚ö†Ô∏è API ÏöîÏ≤≠ Ïã§Ìå®, Ïû¨ÏãúÎèÑ (${retries}Ìöå ÎÇ®Ïùå):`, error.message);
                await this.delay(1000); // 1Ï¥à ÎåÄÍ∏∞
                return this.requestWithRetry(url, options, retries - 1);
            }
            throw error;
        }
    }
    
    /**
     * ÏßÄÏó∞ Ìï®Ïàò
     */
    delay(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
    
    /**
     * NPB ÏàúÏúÑ Îç∞Ïù¥ÌÑ∞ Í∞ÄÏ†∏Ïò§Í∏∞
     */
    async getStandings() {
        // Í∏∞Î≥∏ ÌååÏùº Î°úÎìú. Ïã§Ï†ú Îç∞Ïù¥ÌÑ∞ Ïö∞ÏÑ†ÌôîÎ•º ÏúÑÌï¥ loadAllDataÏóêÏÑú seasonData Í∏∞Î∞òÏúºÎ°ú Ïû¨Í≥ÑÏÇ∞Ìï®.
        const data = await this.requestWithRetry(`${this.baseUrl}/npb-standings.json`);
        return this.processStandingsData(data);
    }
    
    /**
     * NPB ÌåÄ ÌÜµÍ≥Ñ Îç∞Ïù¥ÌÑ∞ Í∞ÄÏ†∏Ïò§Í∏∞
     */
    async getTeamStats() {
        const data = await this.requestWithRetry(`${this.baseUrl}/npb-team-stats.json`);
        return this.processTeamStatsData(data);
    }
    
    /**
     * NPB Í≤ΩÍ∏∞ Í∏∞Î°ù Í∞ÄÏ†∏Ïò§Í∏∞
     */
    async getGameRecords() {
        const data = await this.requestWithRetry(`${this.baseUrl}/npb-game-records.json`);
        return this.processGameRecordsData(data);
    }
    
    /**
     * ÏãúÏ¶å Îç∞Ïù¥ÌÑ∞ Í∞ÄÏ†∏Ïò§Í∏∞ (ÌÅ¨Î°§ÎßÅÎêú Îç∞Ïù¥ÌÑ∞)
     */
    async getSeasonData() {
        const data = await this.requestWithRetry(`${this.baseUrl}/npb-2025-season-data.json`);
        return data;
    }
    
    /**
     * Î™®Îì† Îç∞Ïù¥ÌÑ∞ ÌïúÎ≤àÏóê Î°úÎìú
     */
    async loadAllData() {
        console.log('üì° NPB Îç∞Ïù¥ÌÑ∞ Î°úÎî© ÏãúÏûë...');
        
        try {
            // ÏãúÏ¶å Îç∞Ïù¥ÌÑ∞ Ïö∞ÏÑ† Î°úÎìú(Ïã§Ï†ú Îç∞Ïù¥ÌÑ∞ Í≥ÑÏÇ∞ Í∏∞Î∞ò)
            const seasonData = await this.getSeasonData().catch(() => null);
            const [standingsRes, teamStatsRes, gameRecordsRes] = await Promise.allSettled([
                this.getStandings(),
                this.getTeamStats(),
                this.getGameRecords()
            ]);

            let standings = standingsRes.status === 'fulfilled' ? standingsRes.value : null;
            let teamStats = teamStatsRes.status === 'fulfilled' ? teamStatsRes.value : null;
            let gameRecords = gameRecordsRes.status === 'fulfilled' ? gameRecordsRes.value : null;

            // ÏãúÏ¶å Îç∞Ïù¥ÌÑ∞Í∞Ä ÏûàÏúºÎ©¥ Ïù¥Î•º Í∏∞Î∞òÏúºÎ°ú Ïã§ÏãúÍ∞Ñ Í≥ÑÏÇ∞ÌïòÏó¨ ÎçÆÏñ¥Ïì∞Í∏∞
            if (seasonData && Array.isArray(seasonData)) {
                try {
                    standings = this.buildStandingsFromSeasonData(seasonData);
                } catch (e) { console.warn('standings Ïû¨Í≥ÑÏÇ∞ Ïã§Ìå®:', e.message); }
                try {
                    teamStats = this.buildTeamStatsFromSeasonData(seasonData);
                } catch (e) { console.warn('teamStats Ïû¨Í≥ÑÏÇ∞ Ïã§Ìå®:', e.message); }
                try {
                    gameRecords = this.buildGameRecordsFromSeasonData(seasonData);
                } catch (e) { console.warn('gameRecords Ïû¨Íµ¨ÏÑ± Ïã§Ìå®:', e.message); }
            }

            const result = { standings, teamStats, gameRecords, seasonData, loadTime: new Date() };
            
            console.log('‚úÖ NPB Îç∞Ïù¥ÌÑ∞ Î°úÎî© ÏôÑÎ£å:', result);
            return result;
        } catch (error) {
            console.error('‚ùå NPB Îç∞Ïù¥ÌÑ∞ Î°úÎî© Ïã§Ìå®:', error);
            throw error;
        }
    }
    
    /**
     * ÏàúÏúÑ Îç∞Ïù¥ÌÑ∞ Ï≤òÎ¶¨
     */
    processStandingsData(data) {
        // dataÍ∞Ä Í∞ùÏ≤¥Ïù¥Í≥† standings Î∞∞Ïó¥ÏùÑ Í∞ÄÏßÄÍ≥† ÏûàÎäî Í≤ΩÏö∞
        if (data && data.standings && Array.isArray(data.standings)) {
            return data.standings.map(team => ({
                ...team,
                winPct: team.winPct || ((team.wins + team.losses) > 0 ? team.wins / (team.wins + team.losses) : 0),
                gamesBehind: team.gamesBehind || 0
            }));
        }
        // dataÍ∞Ä ÏßÅÏ†ë Î∞∞Ïó¥Ïù∏ Í≤ΩÏö∞ (legacy ÏßÄÏõê)
        else if (Array.isArray(data)) {
            return data.map(team => ({
                ...team,
                winPct: team.winPct || ((team.wins + team.losses) > 0 ? team.wins / (team.wins + team.losses) : 0),
                gamesBehind: team.gamesBehind || 0
            }));
        }
        return null;
    }
    
    /**
     * ÌåÄ ÌÜµÍ≥Ñ Îç∞Ïù¥ÌÑ∞ Ï≤òÎ¶¨
     */
    processTeamStatsData(data) {
        return data || null;
    }
    
    /**
     * Í≤ΩÍ∏∞ Í∏∞Î°ù Îç∞Ïù¥ÌÑ∞ Ï≤òÎ¶¨
     */
    processGameRecordsData(data) {
        return data || null;
    }
    
    /**
     * Î™©ÏóÖ ÏàúÏúÑ Îç∞Ïù¥ÌÑ∞ (Í∞úÎ∞úÏö©)
     */
    // ÏãúÏ¶å Îç∞Ïù¥ÌÑ∞ Í∏∞Î∞ò Ïã§ÏãúÍ∞Ñ Í≥ÑÏÇ∞Í∏∞Îì§
    buildStandingsFromSeasonData(seasonData) {
        const teamSet = new Set();
        seasonData.forEach(day => (day.games || []).forEach(g => {
            teamSet.add(NPBUtils.normalizeTeamName(g.homeTeam || g.home));
            teamSet.add(NPBUtils.normalizeTeamName(g.awayTeam || g.away));
        }));
        const teams = Array.from(teamSet);
        const tally = new Map(teams.map(t => [t, { wins:0, losses:0, draws:0 }]));
        const days = [...seasonData].sort((a,b)=> new Date(a.date)-new Date(b.date));
        for (const day of days) {
            for (const g of (day.games || [])) {
                const hs = g.homeScore, as = g.awayScore;
                if (typeof hs !== 'number' || typeof as !== 'number') continue;
                const h = NPBUtils.normalizeTeamName(g.homeTeam || g.home);
                const a = NPBUtils.normalizeTeamName(g.awayTeam || g.away);
                const hT = tally.get(h), aT = tally.get(a);
                if (hs === as) { hT.draws++; aT.draws++; }
                else if (hs > as) { hT.wins++; aT.losses++; }
                else { hT.losses++; aT.wins++; }
            }
        }
        return teams.map(name => {
            const t = tally.get(name);
            const league = NPBUtils.getTeamLeague(name);
            const winPct = NPBUtils.calculateWinPct(t.wins, t.losses, t.draws);
            return { name, league, wins: t.wins, losses: t.losses, draws: t.draws, winPct };
        }).sort((a,b)=> b.winPct - a.winPct || (b.wins - a.wins));
    }

    buildTeamStatsFromSeasonData(seasonData) {
        const teamSet = new Set();
        seasonData.forEach(day => (day.games || []).forEach(g => {
            teamSet.add(NPBUtils.normalizeTeamName(g.homeTeam || g.home));
            teamSet.add(NPBUtils.normalizeTeamName(g.awayTeam || g.away));
        }));
        const teams = Array.from(teamSet);
        const init = () => ({ runsScored:0, runsAllowed:0, wins:0, losses:0, draws:0, homeWins:0, awayWins:0 });
        const map = new Map(teams.map(t=>[t, init()]));
        for (const day of seasonData) {
            for (const g of (day.games || [])) {
                const hs = g.homeScore, as = g.awayScore;
                if (typeof hs !== 'number' || typeof as !== 'number') continue;
                const h = NPBUtils.normalizeTeamName(g.homeTeam || g.home);
                const a = NPBUtils.normalizeTeamName(g.awayTeam || g.away);
                const hm = map.get(h), am = map.get(a);
                hm.runsScored += hs; hm.runsAllowed += as;
                am.runsScored += as; am.runsAllowed += hs;
                if (hs === as) { hm.draws++; am.draws++; }
                else if (hs > as) { hm.wins++; am.losses++; hm.homeWins++; }
                else { am.wins++; hm.losses++; am.awayWins++; }
            }
        }
        return teams.map(name => {
            const s = map.get(name);
            const league = NPBUtils.getTeamLeague(name);
            return { name, league, ...s };
        });
    }

    buildGameRecordsFromSeasonData(seasonData) {
        const games = [];
        let finalCount = 0;
        seasonData.forEach(day => {
            (day.games || []).forEach(g => {
                games.push({
                    date: day.date,
                    homeTeam: g.homeTeam || g.home,
                    awayTeam: g.awayTeam || g.away,
                    homeScore: g.homeScore,
                    awayScore: g.awayScore,
                    status: g.status || g.gameType || null
                });
                if (typeof g.homeScore === 'number' && typeof g.awayScore === 'number') finalCount++;
            });
        });
        return {
            totalGames: finalCount,
            lastUpdate: new Date().toISOString(),
            games
        };
    }
}

// Ï†ÑÏó≠ API ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ïù∏Ïä§ÌÑ¥Ïä§
if (typeof window !== 'undefined') {
    window.npbApiClient = new NPBApiClient();
}

// Node.js ÌôòÍ≤Ω ÏßÄÏõê
if (typeof module !== 'undefined' && module.exports) {
    module.exports = NPBApiClient;
}
