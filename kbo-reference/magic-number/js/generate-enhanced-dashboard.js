const { EnhancedKBODatabase } = require('./enhanced-kbo-database');
const fs = require('fs');
const path = require('path');

class EnhancedDashboardGenerator {
    constructor() {
        this.db = new EnhancedKBODatabase();
    }

    async connect() {
        await this.db.connect();
    }

    async close() {
        await this.db.close();
    }

    async generateComprehensiveDashboard() {
        const dashboard = {
            updateTime: new Date().toISOString(),
            updateDate: new Date().toLocaleDateString('ko-KR', { 
                year: 'numeric', 
                month: 'long', 
                day: 'numeric',
                timeZone: 'Asia/Seoul'
            }),
            
            // 1. Ï¢ÖÌï© ÏàúÏúÑ
            standings: await this.getStandings(),
            
            // 2. ÌîºÌÉÄÍ≥†Î¶¨Ïïà Í∏∞ÎåÄÏäπÎ•† & Ïö¥ ÏßÄÏàò
            pythagoreanAnalysis: await this.getPythagoreanAnalysis(),
            
            // 3. 1Ï†êÏ∞® Í≤ΩÍ∏∞ ÏäπÎ•†
            oneRunGames: await this.getOneRunGames(),
            
            // 4. Ìôà/ÏõêÏ†ï ÏÑ±Ï†Å
            homeAwayStats: await this.getHomeAwayStats(),
            
            // 5. ÏõîÎ≥Ñ ÏäπÎ•†
            monthlyPerformance: await this.getMonthlyPerformance(),
            
            // 6. ÏöîÏùºÎ≥Ñ ÏäπÎ•†
            weekdayPerformance: await this.getWeekdayPerformance(),
            
            // 7. ÏÉÅÎåÄÏ†ÑÏ†Å Îß§Ìä∏Î¶≠Ïä§
            headToHeadMatrix: await this.getHeadToHeadMatrix(),
            
            // 8. Ïó∞Ïäπ/Ïó∞Ìå® ÌòÑÌô©
            streakAnalysis: await this.getStreakAnalysis(),
            
            // 9. ÎìùÏã§Ï†ê Î∂ÑÏÑù
            runAnalysis: await this.getRunAnalysis(),
            
            // 10. ÏÉÅÏúÑÍ∂å/ÌïòÏúÑÍ∂å ÏÉÅÎåÄ ÏäπÎ•†
            vsLevelAnalysis: await this.getVsLevelAnalysis(),
            
            // 11. ÌäπÏàò ÏÉÅÌô© ÌÜµÍ≥Ñ
            specialSituations: await this.getSpecialSituations(),
            
            // 12. Í≤ΩÍ∏∞Ïû•Î≥Ñ ÏÑ±Ï†Å
            stadiumRecords: await this.getStadiumRecords(),
            
            // 13. ÌåÄÎ≥Ñ Ï£ºÏöî ÏßÄÌëú ÏöîÏïΩ
            teamSummaries: await this.getTeamSummaries()
        };
        
        // JSON ÌååÏùºÎ°ú Ï†ÄÏû•
        const outputPath = path.join(__dirname, '../data/enhanced-dashboard.json');
        fs.writeFileSync(outputPath, JSON.stringify(dashboard, null, 2));
        console.log(`üìä Enhanced ÎåÄÏãúÎ≥¥Îìú Îç∞Ïù¥ÌÑ∞ ÏÉùÏÑ±: ${outputPath}`);
        
        return dashboard;
    }

    async getStandings() {
        const standings = await this.db.all(`
            SELECT 
                team_name,
                games_played,
                wins,
                losses,
                draws,
                printf('%.3f', win_rate) as win_rate,
                runs_scored,
                runs_allowed,
                run_differential,
                current_streak
            FROM team_stats
            ORDER BY win_rate DESC, wins DESC
        `);
        
        // Í≤åÏûÑÏ∞® Í≥ÑÏÇ∞
        const leader = standings[0];
        return standings.map((team, index) => ({
            rank: index + 1,
            ...team,
            games_behind: index === 0 ? '-' : 
                ((leader.wins - team.wins) + (team.losses - leader.losses)) / 2
        }));
    }

    async getPythagoreanAnalysis() {
        return await this.db.all(`
            SELECT 
                team_name,
                printf('%.3f', win_rate) as actual_win_rate,
                printf('%.3f', pythagorean_expectation) as expected_win_rate,
                printf('%+.3f', luck_factor) as luck_factor,
                CASE 
                    WHEN luck_factor > 0.05 THEN 'Ïö¥Ïù¥ Ï¢ãÏùå'
                    WHEN luck_factor < -0.05 THEN 'Ïö¥Ïù¥ ÎÇòÏÅ®'
                    ELSE 'ÌèâÍ∑†Ï†Å'
                END as luck_status
            FROM team_stats
            ORDER BY win_rate DESC
        `);
    }

    async getOneRunGames() {
        return await this.db.all(`
            SELECT 
                team_name,
                one_run_games_won as wins,
                one_run_games_lost as losses,
                one_run_games_won + one_run_games_lost as total_games,
                printf('%.3f', one_run_win_rate) as win_rate
            FROM team_stats
            WHERE one_run_games_won + one_run_games_lost > 0
            ORDER BY one_run_win_rate DESC
        `);
    }

    async getHomeAwayStats() {
        return await this.db.all(`
            SELECT 
                team_name,
                home_wins,
                home_losses,
                printf('%.3f', home_win_rate) as home_win_rate,
                away_wins,
                away_losses,
                printf('%.3f', away_win_rate) as away_win_rate,
                printf('%+.3f', home_advantage_index) as home_advantage
            FROM team_stats
            ORDER BY win_rate DESC
        `);
    }

    async getMonthlyPerformance() {
        const monthlyData = await this.db.all(`
            SELECT 
                team_name,
                month,
                wins,
                losses,
                draws,
                (wins + losses + draws) as games,
                printf('%.3f', win_rate) as win_rate,
                runs_scored,
                runs_allowed
            FROM monthly_records
            WHERE year = 2025
            ORDER BY team_name, month
        `);
        
        // ÌåÄÎ≥ÑÎ°ú Í∑∏Î£πÌôî
        const grouped = {};
        monthlyData.forEach(record => {
            if (!grouped[record.team_name]) {
                grouped[record.team_name] = [];
            }
            grouped[record.team_name].push({
                month: record.month,
                wins: record.wins,
                losses: record.losses,
                draws: record.draws,
                games: record.games,
                win_rate: record.win_rate,
                runs_scored: record.runs_scored,
                runs_allowed: record.runs_allowed
            });
        });
        
        return grouped;
    }

    async getWeekdayPerformance() {
        const weekdayData = await this.db.all(`
            SELECT 
                team_name,
                day_of_week,
                wins,
                losses,
                draws,
                printf('%.3f', win_rate) as win_rate
            FROM weekday_records
            ORDER BY team_name, 
                CASE day_of_week
                    WHEN 'Ïõî' THEN 1
                    WHEN 'Ìôî' THEN 2
                    WHEN 'Ïàò' THEN 3
                    WHEN 'Î™©' THEN 4
                    WHEN 'Í∏à' THEN 5
                    WHEN 'ÌÜ†' THEN 6
                    WHEN 'Ïùº' THEN 7
                END
        `);
        
        // ÌåÄÎ≥ÑÎ°ú Í∑∏Î£πÌôî
        const grouped = {};
        weekdayData.forEach(record => {
            if (!grouped[record.team_name]) {
                grouped[record.team_name] = {};
            }
            grouped[record.team_name][record.day_of_week] = {
                wins: record.wins,
                losses: record.losses,
                draws: record.draws,
                win_rate: record.win_rate
            };
        });
        
        return grouped;
    }

    async getHeadToHeadMatrix() {
        const teams = ['KIA', 'LG', 'ÏÇºÏÑ±', 'ÎëêÏÇ∞', 'KT', 'SSG', 'Î°ØÎç∞', 'ÌïúÌôî', 'NC', 'ÌÇ§ÏõÄ'];
        const matrix = {};
        
        for (const team of teams) {
            matrix[team] = {};
            for (const opponent of teams) {
                if (team === opponent) {
                    matrix[team][opponent] = '-';
                    continue;
                }
                
                const games = await this.db.all(`
                    SELECT winner, COUNT(*) as count
                    FROM games
                    WHERE (home_team = ? AND away_team = ?) 
                       OR (home_team = ? AND away_team = ?)
                    GROUP BY winner
                `, [team, opponent, opponent, team]);
                
                let wins = 0, losses = 0;
                games.forEach(g => {
                    if (g.winner === team) wins = g.count;
                    else if (g.winner === opponent) losses = g.count;
                });
                
                matrix[team][opponent] = {
                    record: `${wins}-${losses}`,
                    win_rate: wins + losses > 0 ? (wins / (wins + losses)).toFixed(3) : '0.000'
                };
            }
        }
        
        return matrix;
    }

    async getStreakAnalysis() {
        return await this.db.all(`
            SELECT 
                team_name,
                current_streak,
                max_win_streak,
                max_lose_streak,
                CASE 
                    WHEN current_streak LIKE '%W' THEN 'Ïó∞Ïäπ Ï§ë'
                    WHEN current_streak LIKE '%L' THEN 'Ïó∞Ìå® Ï§ë'
                    ELSE 'Î¨¥ÏäπÎ∂Ä'
                END as streak_status
            FROM team_stats
            ORDER BY win_rate DESC
        `);
    }

    async getRunAnalysis() {
        return await this.db.all(`
            SELECT 
                team_name,
                runs_scored,
                runs_allowed,
                run_differential,
                printf('%.2f', CAST(runs_scored AS FLOAT) / games_played) as avg_runs_scored,
                printf('%.2f', CAST(runs_allowed AS FLOAT) / games_played) as avg_runs_allowed,
                printf('%.2f', CAST(run_differential AS FLOAT) / games_played) as avg_run_diff
            FROM team_stats
            ORDER BY run_differential DESC
        `);
    }

    async getVsLevelAnalysis() {
        return await this.db.all(`
            SELECT 
                team_name,
                vs_above_500_wins as vs_above_wins,
                vs_above_500_losses as vs_above_losses,
                CASE 
                    WHEN vs_above_500_wins + vs_above_500_losses > 0 
                    THEN printf('%.3f', CAST(vs_above_500_wins AS FLOAT) / 
                                (vs_above_500_wins + vs_above_500_losses))
                    ELSE '0.000'
                END as vs_above_win_rate,
                vs_below_500_wins as vs_below_wins,
                vs_below_500_losses as vs_below_losses,
                CASE 
                    WHEN vs_below_500_wins + vs_below_500_losses > 0 
                    THEN printf('%.3f', CAST(vs_below_500_wins AS FLOAT) / 
                                (vs_below_500_wins + vs_below_500_losses))
                    ELSE '0.000'
                END as vs_below_win_rate
            FROM team_stats
            ORDER BY win_rate DESC
        `);
    }

    async getSpecialSituations() {
        return await this.db.all(`
            SELECT 
                team_name,
                blowout_wins,
                blowout_losses,
                shutout_wins,
                shutout_losses,
                one_run_games_won + one_run_games_lost as close_games,
                blowout_wins + blowout_losses as blowout_games,
                shutout_wins + shutout_losses as shutout_games
            FROM team_stats
            ORDER BY win_rate DESC
        `);
    }

    async getStadiumRecords() {
        const stadiumData = await this.db.all(`
            SELECT 
                team_name,
                stadium,
                wins,
                losses,
                draws,
                printf('%.3f', win_rate) as win_rate
            FROM stadium_records
            ORDER BY team_name, stadium
        `);
        
        // ÌåÄÎ≥ÑÎ°ú Í∑∏Î£πÌôî
        const grouped = {};
        stadiumData.forEach(record => {
            if (!grouped[record.team_name]) {
                grouped[record.team_name] = [];
            }
            grouped[record.team_name].push({
                stadium: record.stadium,
                wins: record.wins,
                losses: record.losses,
                draws: record.draws,
                win_rate: record.win_rate
            });
        });
        
        return grouped;
    }

    async getTeamSummaries() {
        const teams = await this.db.all(`
            SELECT * FROM team_stats ORDER BY win_rate DESC
        `);
        
        return teams.map(team => ({
            team_name: team.team_name,
            overall: {
                record: `${team.wins}Ïäπ ${team.draws}Î¨¥ ${team.losses}Ìå®`,
                win_rate: team.win_rate.toFixed(3),
                games_behind: 0 // Í≥ÑÏÇ∞ ÌïÑÏöî
            },
            pythagorean: {
                expected: team.pythagorean_expectation.toFixed(3),
                actual: team.win_rate.toFixed(3),
                luck_factor: team.luck_factor.toFixed(3)
            },
            situational: {
                one_run: `${team.one_run_games_won}-${team.one_run_games_lost}`,
                one_run_rate: team.one_run_win_rate.toFixed(3),
                blowout: `${team.blowout_wins}-${team.blowout_losses}`,
                shutout: `${team.shutout_wins}-${team.shutout_losses}`
            },
            home_away: {
                home: `${team.home_wins}-${team.home_losses} (${team.home_win_rate.toFixed(3)})`,
                away: `${team.away_wins}-${team.away_losses} (${team.away_win_rate.toFixed(3)})`,
                advantage: team.home_advantage_index.toFixed(3)
            },
            vs_level: {
                above_500: `${team.vs_above_500_wins}-${team.vs_above_500_losses}`,
                below_500: `${team.vs_below_500_wins}-${team.vs_below_500_losses}`
            },
            streaks: {
                current: team.current_streak,
                max_win: team.max_win_streak,
                max_lose: team.max_lose_streak
            },
            runs: {
                scored: team.runs_scored,
                allowed: team.runs_allowed,
                differential: team.run_differential,
                avg_scored: (team.runs_scored / team.games_played).toFixed(2),
                avg_allowed: (team.runs_allowed / team.games_played).toFixed(2)
            }
        }));
    }
}

// Î©îÏù∏ Ïã§Ìñâ
async function main() {
    const generator = new EnhancedDashboardGenerator();
    
    try {
        await generator.connect();
        const dashboard = await generator.generateComprehensiveDashboard();
        
        console.log('\n‚úÖ Enhanced ÎåÄÏãúÎ≥¥Îìú ÏÉùÏÑ± ÏôÑÎ£å!');
        console.log('\nüìä Ï£ºÏöî ÏßÄÌëú ÏöîÏïΩ:');
        console.log('1. ÌîºÌÉÄÍ≥†Î¶¨Ïïà Î∂ÑÏÑù - Ïö¥Ïù¥ Ï¢ãÏùÄ ÌåÄ:');
        dashboard.pythagoreanAnalysis
            .filter(t => t.luck_factor > 0.03)
            .forEach(t => console.log(`   ${t.team_name}: ${t.luck_factor}`));
        
        console.log('\n2. 1Ï†êÏ∞® Í≤ΩÍ∏∞ Í∞ïÌåÄ:');
        dashboard.oneRunGames
            .slice(0, 3)
            .forEach(t => console.log(`   ${t.team_name}: ${t.win_rate} (${t.wins}Ïäπ ${t.losses}Ìå®)`));
        
        console.log('\n3. Ìôà Ïñ¥ÎìúÎ∞¥Ìã∞ÏßÄ TOP 3:');
        dashboard.homeAwayStats
            .sort((a, b) => parseFloat(b.home_advantage) - parseFloat(a.home_advantage))
            .slice(0, 3)
            .forEach(t => console.log(`   ${t.team_name}: ${t.home_advantage}`));
        
        await generator.close();
    } catch (error) {
        console.error('‚ùå Ïò§Î•ò Î∞úÏÉù:', error);
        await generator.close();
    }
}

if (require.main === module) {
    main();
}

module.exports = { EnhancedDashboardGenerator };